<html>
    <head>
        <link rel="stylesheet" type="text/css" href="gameComponents/game.css">
        <script>
            
            
            if (!(window.game == null || window.game == undefined)){
                window.game.purge();
                window.game = null;
            }
            window.game= new gameObject();
                
                
            function gameObject(){ 
                /**
                 * Calculates the rotation of an object from a transformatino matrix
                 * @author Ignacy Debicki
                 * @param   {object} obj Object to get rotation of
                 * @returns {number} Rotation in degrees
                 */
                function getRotationDegrees(obj) {
                    var matrix = obj.css("-webkit-transform") ||
                    obj.css("-moz-transform")    ||
                    obj.css("-ms-transform")     ||
                    obj.css("-o-transform")      ||
                    obj.css("transform");
                    if(matrix !== 'none') {
                        var values = matrix.split('(')[1].split(')')[0].split(',');
                        var a = values[0];
                        var b = values[1];
                        var angle = Math.round(Math.atan2(b, a) * (180/Math.PI));
                    } else { var angle = 0; }
                    angle = angle%360;
                    if (angle>180){
                        angle = angle-360;
                    }else if(angle<=-180){
                        angle = 360+angle;
                    }
                    return Math.round(angle*10)/10;
                }
                /**
                 * Calculates the  route to rotate
                 * @author Ignacy Debicki
                 * @param   {number} s Start rotation
                 * @param   {number} e End of rotation
                 * @returns {number} Angle to rotate to
                 */
                function getShortestRotation(s,e){
                    if ((e<s && (e > s - 180 || e > s + 180)) || (e>s && ( s + 180 < e))){
                        //rotate left
                        if ( s < 0 && e > 0){
                            return e - 360;
                        }else{
                            return e;
                        }
                    }else{
                        //rotate right
                        if (s > 0 && e < 0){
                            return 360 + e
                        }else{
                           return e 
                        }
                         
                    }
                }
                /**
                 * CSS3 Jquery animated rotation
                 * @author yckart http://stackoverflow.com/questions/15191058/css-rotation-cross-browser-with-jquery-animate
                 * @param   {number}   angle    Angle to rotate to in degrees
                 * @param   {number}   duration Length of animation
                 * @param   {string}   easing   Type of easing: linear or swing
                 * @param   {function} complete Completion handler
                 */
                $.fn.animateRotate = function(angle,duration, easing, complete) {
                    angle = angle%360;
                    if (angle>180){
                        angle = angle-360;
                    }else if(angle<=-180){
                        angle = 360+angle;
                    }
                    var args = $.speed(duration, easing, complete);
                    var step = args.step;
                    return this.each(function(i, e) {
                        var startDeg = getRotationDegrees($(e));
                        if (startDeg !== getShortestRotation(startDeg,angle) || startDeg !== angle){
                            args.complete = $.proxy(args.complete, e);
                            args.step = function(now) {
                            $.style(e, 'transform', 'rotate(' + now + 'deg)');
                                if (step) return step.apply(e, arguments);
                            };


                        $({deg: startDeg}).animate({deg: getShortestRotation(startDeg,angle)}, args);
                        }
                    });
                };
                /**
                 * Creates a new VectorPathSegment object
                 * @author Ignacy Debicki
                 * @constructor
                 * @param {number} x           X (i) value of unit vector direction
                 * @param {number} y           Y (j) value of unit vector direction
                 * @param {number} magnitude   Length of vector
                 * @param {Array}  links       Array of vectors which directly follow on from current vector.
                 *                             Has form of [{'segment' : nextVectorPathSegment, 'p' : probabilityForVectorSelection}]
                 * @param {number} id          Identifier of the vector
                 * @param {number} weight      The weight of the vector
                 * @param {number} maxDistance The maximum distance an enemy may have traveled when reaching the start of the sector
                 */
                function VectorPathSegment(x,y,magnitude,links,id,weight,prevLinks,maxDistance){
                    this.x = typeof x !== 'undefined' ? x : null;
                    this.y = typeof y !== 'undefined' ? y : null;
                    this.m = typeof magnitude !== 'undefined' ? magnitude : null;
                    this.links = typeof links !== 'undefined' ? links : [];
                    this.id = typeof id !== 'undefined' ? id : null;
                    this.weight = typeof weight !== 'undefined' ? weight : null;
                    this.maxDistance = typeof maxDistance !== 'undefined' ? maxDistance : null;
                }
                    
                VectorPathSegment.prototype = {
                    /**
                     * Randomly chooses and returns the next segment from this segments segment links. Returns null if no next segment exists.
                     * @author Ignacy Debicki
                     * @returns {object} Reference to next vectorPathSegment or null if no next vectorPathSegment exists.
                     */
                    next: function(){
                        if (this.links.length==1){
                            return this.links[0].segment;
                        }else if(this.links.length==0){
                            return null;
                        }else{
                            //more than one
                            var p = this.links[0].p;
                            var rand = Math.random();
                            var link = 0;
                            while (rand>p){
                                link++;
                                p+=this.links[link].p;
                            }
                            return this.links[link].segment;
                        }
                    },
                    /**
                     * Adds a new link to the vectorPathSegment
                     * @author Ignacy Debicki
                     * @param {object} segment     vectorPathSegment to create a new link to
                     * @param {number} probability Probability this segment will be returned as the next segment (range: 0->1);
                     */
                    addLink: function(segment,probability){
                        this.links.push({'segment':segment,'p':probability});
                    },
                    /**
                     * Gets the ID of a segment
                     * @author Ignacy Debicki
                     * @returns {number} Id of the segment
                     */
                    getId: function(){
                        return this.id;
                    },
                    /**
                     * Sets the ID of a segment
                     * @author Ignacy Debicki
                     * @param {number} newID The new id to be set
                     */
                    setId: function(newID){
                        this.id = newID;
                    },
                    /**
                     * Finds a segment of a specific ID
                     * @author Ignacy Debicki
                     * @param   {id} id Id of segment to find
                     * @returns {object} Returns either false if the segment was not found, or a VectorPathSegment if found
                     */
                    findSegmentOfID: function(id){
                        if(this.id==id){
                            return this;
                        }else if (this.links.length > 0){
                            for (var i = 0; i < this.links.length; i++){
                                var segment = this.links[i].segment.findSegmentOfID(id);
                                if (segment!==false){
                                    return segment;
                                }
                            }
                            return false;
                        }else{
                            return false;
                        }
                    },
                    /**
                     * Calculates the weight of this segment and all the segments below this segment in the tree
                     * @author Ignacy Debicki
                     * @returns {number} The segments weight + its magnitude
                     */
                    setWeight: function(){
                        var distanceArray = [];
                        for (var i =0; i<this.links.length;i++){
                            distanceArray.push(this.links[i].segment.setWeight());
                        }
                        if (distanceArray.length>0){
                            this.weight = Math.max(...distanceArray);
                        }else{
                            this.weight = 0;
                        }
                        
                        return this.weight + this.m;
                    }
                };
                /**
                 * Bounding box collision test - does not account for rotation
                 * @author Ignacy Debicki
                 * @param   {object}  e1 Element to test (given already as $(element))
                 * @param   {object}  e2 Element to test (given already as $(element))
                 * @returns {boolean} If collision has occured
                 */
                function simpleSqCollision(e1, e2) {
                      var x1 = e1.offset().left;
                      var y1 = e1.offset().top;
                      var h1 = e1.outerHeight(true);
                      var w1 = e1.outerWidth(true);
                      var b1 = y1 + h1;
                      var r1 = x1 + w1;
                      var x2 = e2.offset().left;
                      var y2 = e2.offset().top;
                      var h2 = e2.outerHeight(true);
                      var w2 = e2.outerWidth(true);
                      var b2 = y2 + h2;
                      var r2 = x2 + w2;

                      if (b1 < y2 || y1 > b2 || r1 < x2 || x1 > r2) return false;
                      return true;
                }
                /**
                 * Checks if an element has collided with a game tile
                 * @author Ignacy Debicki
                 * @param   {object}  tile   Tile to be tested. Should be passed in as $(tile)
                 * @param   {object}  object Object to be tested. Should be passed in as $(object)
                 * @returns {boolean} If collision occured
                 */
                function tileCollision(tile,object){
                    
                    if (tile.hasClass("mapPathTile")){
                        var sqPoints = [];
                        var crPoints = [];
                        var objectPoints = [];
                        sqPoints.push({'x':tile.children("#nw.marker").offset().left,
                                   'y':tile.children("#nw.marker").offset().top});
                        sqPoints.push({'x':tile.children("#ne.marker").offset().left,
                                       'y':tile.children("#ne.marker").offset().top});
                        sqPoints.push({'x':tile.children("#se.marker").offset().left,
                                       'y':tile.children("#se.marker").offset().top});
                        sqPoints.push({'x':tile.children("#sw.marker").offset().left,
                                       'y':tile.children("#sw.marker").offset().top});

                        crPoints.push({'x':tile.children("#cw.marker").offset().left,
                                       'y':tile.children("#cw.marker").offset().top,
                                       'r':gameObjectVars.pathRadius});
                        crPoints.push({'x':tile.children("#ce.marker").offset().left,
                                       'y':tile.children("#ce.marker").offset().top,
                                       'r':gameObjectVars.pathRadius});

                        objectPoints.push({'x':object.offset().left,
                                           'y':object.offset().top});
                        objectPoints.push({'x':object.offset().left + object.outerWidth(),
                                           'y':object.offset().top});
                        objectPoints.push({'x':object.offset().left + object.outerWidth(),
                                           'y':object.offset().top + object.outerHeight()});
                        objectPoints.push({'x':object.offset().left,
                                           'y':object.offset().top + object.outerHeight()});
                    
                    return (advancedSqCollision(sqPoints,objectPoints) || circleSqCollision(crPoints[0],objectPoints) || circleSqCollision(crPoints[1],objectPoints));
                        
                    }else{
                        return simpleSqCollision(tile,object);
                    }
                    
                    
                }
                /**
                 * Tests the collision of a cirle element with a rectangular element
                 * @author Ignacy Debicki
                 * @param   {object}  circle Reference to circle object. Should be passed in as $(circle)
                 * @param   {array}  square Reference to corner points of rectangle.
                 * @returns {boolean} If collision occured
                 */
                function circleSqCollision(circle,square){
                    
                    for (var i = 0; i<3;i++){
                        var A = square[i];
                        var B = square[i+1];
                        if (crLineCollision(circle,[A,B])==true){
                            return true
                        }
                    }
                    return false
                }
                /**
                 * Tests for collision of line with circle
                 * @author Ignacy Debicki
                 * @param   {object}  circle     Circle element. Should be passed in as $(circle)
                 * @param   {Array}   linePoints Array of points that make up the line (A,B)
                 * @returns {boolean} IF collision occured
                 */
                function crLineCollision(circle,linePoints){
                    
                    if (Math.sqrt(Math.pow(linePoints[0].x-circle.x,2)+Math.pow(linePoints[0].y-circle.y,2))<circle.r ||
                        Math.sqrt(Math.pow(linePoints[1].x-circle.x,2)+Math.pow(linePoints[1].y-circle.y,2))<circle.r
                       ){
                        return true;
                    }
                    
                    var directionVector = {'x':(linePoints[0].x - linePoints[1].x),'y':(linePoints[0].y - linePoints[1].y)};
                    var magnitudeLimit = Math.sqrt(Math.pow(directionVector.x,2)+Math.pow(directionVector.y,2));
                    //obtain unit vector
                    directionVector.x/=magnitudeLimit;
                    directionVector.y/=magnitudeLimit;
                    var a = Math.pow(directionVector.x,2)+Math.pow(directionVector.y,2);
                    var b = 2*(directionVector.x*linePoints[0].x+directionVector.y*linePoints[0].y-circle.x*directionVector.x-circle.y*directionVector.y)
                    var c = Math.pow(circle.x,2)+ Math.pow(circle.y,2)+ Math.pow(linePoints[0].x,2)+ Math.pow(linePoints[0].y,2)- 2*(linePoints[0].x*circle.x+linePoints[0].y*circle.y)-Math.pow(circle.r,2);
                    
                    var determinant = Math.pow(b,2)-4*a*c;
                    if (determinant==0){
                        var lambda = Math.pow(b,2)/(2*a);
                        if (lambda<=magnitudeLimit && lambda >= 0){
                            return true;
                        }
                    }else if(determinant>0){
                        var lambda = [(Math.pow(b,2)-Math.sqrt(determinant))/(2*a),
                                      (Math.pow(b,2)+Math.sqrt(determinant))/(2*a)];
                        for (var i = 0;i<2;i++){
                            var l = lambda[i];
                            if (l<=magnitudeLimit && l >= 0){
                                return true;
                            }
                        }   
                    }
                    return false;
                }
                            
                /**
                 * Determines if two rectangles collide - with collision
                 * @author Ignacy Debicki
                 * @param   {object}  a Reference to object a. Should be passed in as $(a)
                 * @param   {object}  b Reference to object b. Should be passed in as $(b)
                 * @returns {boolean} If collision occured
                 */
                function advancedSqCollision (a, b) {

                    var polygons = [a, b];
                    var minA, maxA, projected, i, i1, j, minB, maxB;

                    for (i = 0; i < polygons.length; i++) {

                        // for each polygon, look at each edge of the polygon, and determine if it separates
                        // the two shapes
                        var polygon = polygons[i];
                        for (i1 = 0; i1 < polygon.length; i1++) {

                            // grab 2 vertices to create an edge
                            var i2 = (i1 + 1) % polygon.length;
                            var p1 = polygon[i1];
                            var p2 = polygon[i2];

                            // find the line perpendicular to this edge
                            var normal = { x: p2.y - p1.y, y: p1.x - p2.x };

                            minA = maxA = undefined;
                            // for each vertex in the first shape, project it onto the line perpendicular to the edge
                            // and keep track of the min and max of these values
                            for (j = 0; j < a.length; j++) {
                                projected = normal.x * a[j].x + normal.y * a[j].y;
                                if (minA===undefined || projected < minA) {
                                    minA = projected;
                                }
                                if (maxA===undefined || projected > maxA) {
                                    maxA = projected;
                                }
                            }

                            // for each vertex in the second shape, project it onto the line perpendicular to the edge
                            // and keep track of the min and max of these values
                            minB = maxB = undefined;
                            for (j = 0; j < b.length; j++) {
                                projected = normal.x * b[j].x + normal.y * b[j].y;
                                if (minB===undefined || projected < minB) {
                                    minB = projected;
                                }
                                if (maxB===undefined || projected > maxB) {
                                    maxB = projected;
                                }
                            }

                            // if there is no overlap between the projects, the edge we are looking at separates the two
                            // polygons, and we know there is no overlap
                            if (maxA < minB || maxB < minA) {
                                return false;
                            }
                        }
                    }
                    return true;
                };
                /**
                 * Simple circle - rectangle collision test - no rotation
                 * @author Ignacy Debicki
                 * @param   {object}  circle Reference to circle. Should be passed in as $(circle)
                 * @param   {object}  rect   Reference to rectangle. Should be passed in as $(rect)
                 * @returns {boolean} If collision occurs
                 */
                function crCollision(circle, rect) {
                    var cr = circle.outerWidth(true)/2;
                    var cx = circle.offset().left+cr;
                    var cy = circle.offset().top+cr;

                    var rx = rect.offset().left;
                    var ry = rect.offset().top;
                    var rh = rect.outerHeight(true);
                    var rw = rect.outerWidth(true);
                    var distX = Math.abs(cx - rx - rw / 2);
                    var distY = Math.abs(cy - ry - rh / 2);

                    if (distX > (rw / 2 + cr)) {
                        return false;
                    }
                    if (distY > (rh / 2 + cr)) {
                        return false;
                    }

                    if (distX <= (rw / 2)) {
                        return true;
                    }
                    if (distY <= (rh / 2)) {
                        return true;
                    }

                    var dx = distX - rw / 2;
                    var dy = distY - rh / 2;
                    return (dx * dx + dy * dy <= (cr * cr));
                }
                /**
                 * Ranks an array of enemy objects by the distance they have travelled
                 * @author Ignacy Debicki
                 * @param   {Array} enemies Array of enemy objects
                 * @returns {Array} Array of sorted by distance (Descending) enemies.
                 */
                function rankByDistance(enemies){
                    return enemies.sort(function(a,b){
                        return (($(a).data("currentVector").weight+$(a).data("magnitudeRemaining"))-($(b).data("currentVector").weight+$(b).data("magnitudeRemaining")))/Math.abs((($(a).data("currentVector").weight+$(a).data("magnitudeRemaining"))-($(b).data("currentVector").weight+$(b).data("magnitudeRemaining"))));
                    });;
                }
                
                var gameObjectVars = this;
                //init global vars
                this.baseClock = 300;
                this.clockMultiplier = 1;
                this.prevClockMultiplier = 1;
                this.clockTime = 0;
                //set constants
                this.gameHeight = 675;
                this.gameWidth = 875;
                this.baseHealth = 100;
                this.score = 0;
                this.mapPath = [];
                this.vectorPath = [];
                this.vectorPathRoot = null;
                this.pathRadius = 0;
                this.towers = [];
                this.stopTickFunction = false;
                this.enemyQueue = {};
                this.enemyDB = {};
                this.towerDB = {};
                this.projectileDB = {};
                this.currentDrag = null;
                this.mousePos = { x: 0, y: 0 };
                this.maxHealth = 100;
                this.resources = 0;
                this.startingResources = 0;
                this.waves = [];
                this.waveNo = 0;
                this.events = {};
                this.timeUntilWave = 30;
                this.stopWaveTimer = false
                this.runTick = false;
                this.pauseWaveTimer = false;
                this.clockTickRunning=true;
                this.valid = true;
                this.warningMessageTimeout=null;
                this.animationArray = [];
                this.mapID = null;
                this.statistics = {};
                this.experience = 0;
                this.experienceMultiplier = 1;
                this.experienceGained = 0;
                
                $("document").ready(function(){
                    //set self to hidden
                    $("#controlTray").hide('fade',0,function(){
                        $("#controlTray").removeAttr("display");
                    });
                    $("#sideBarTowerControl").css("display","block");
                    $("#sideBarTowerControl").velocity("slideUp",0);
                    hideUpgradeStats();
                    hideWarning();
                    initiateStatistics();
                    if (window.login.isLoggedIn()){
                        window.login.getExperience(function(success,data,errorCode){
                            if (success){
                                gameObjectVars.experience = parseInt(data);
                                updateLockedTowers();
                            }else{
                                alert(data,errorCode);
                            }
                        });
                        window.login.getXPMultiplier(function(success,data,errorCode){
                            if(success){
                                gameObjectVars.experienceMultiplier = parseInt(data);
                            }else{
                                alert(data,errorCode);
                            }
                        });  
                    }
                    

                    //set handlers
                    $(".timeControl").click(changePlaybackTime);
                    $("#healthBar").progressbar({
                        disabled: false,
                        max: gameObjectVars.maxHealth,
                        value: gameObjectVars.baseHealth
                    })
                    $("#sellTower").click(sellTower);
                    $("#upgradeTower").click(upgradeTower);
                    $("#upgradeTower").hover(showUpgradeStats,hideUpgradeStats);
                    $("#startWave").click(function(){gameObjectVars.stopWaveTimer=true;});

                    $(document).mousemove(function(event) {
                        gameObjectVars.mousePos.x = event.pageX;
                        gameObjectVars.mousePos.y = event.pageY;
                    });
                    $("#gameSpace").mousedown(removeTowerSelection);
                });


                $(document).keyup(function(e) {
                    if (e.keyCode == 27) { 
                        // escape key pressed - if moving any tower, stop moving and refund
                        $(".isDragging").each(function(i,e){
                            //refund resources
                            if ($(this).data("price") > 0){
                                setResources(gameObjectVars.resources+$(this).data("price"));
                            }
                            //remove handlers
                            $('#gameSpace').unbind("");
                            //reassign necessary functions
                            $("#gameSpace").mousedown(removeTowerSelection);
                            //remove tower
                            $(this).remove();
                        });
                    }
                });
                
                function updateLockedTowers(){
                    $(".sideBarTowerDiv.locked").each(function(){
                        if ($(this).data("experience")<=Math.round(gameObjectVars.experience + gameObjectVars.experienceGained)){
                            //unlock
                            $(this).removeClass("locked");
                            $(this).children(".sideBarTowerCover").remove();
                            $(this).children(".towerSideBarImage").click(buyTower);
                        }else{
                            console.log($(this).children(".experienceValue").children(".sideBarTowerCover").children(".experienceValue"));
                            $(this).children(".sideBarTowerCover").children(".experienceValue").html($(this).data("experience")-Math.round(gameObjectVars.experience+ gameObjectVars.experienceGained));
                        }
                    });
                }
                /**
                 * initiates all statistics to their initial values
                 * @author Ignacy Debicki
                 */
                function initiateStatistics(){
                    gameObjectVars.statistics["enemiesKilled"]=0;
                    gameObjectVars.statistics["towersBuilt"]=0;
                    gameObjectVars.statistics["towersUpgraded"]=0;
                    gameObjectVars.statistics["projectilesFired"]=0;
                }
                /**
                 * Increments the specified statistic
                 * @author Ignacy Debicki
                 * @param {string} statistic Options are: enemiesKilled, towersBuilt, towersUpgraded or projectilesFired
                 */
                function incrementStatistic(statistic){
                    gameObjectVars.statistics[statistic]++;
                }
                /**
                 * Starts the game tick and shows control elements
                 * @author Ignacy Debicki
                 */
                function start(){
                    //set wave number to 0
                    gameObjectVars.waveNo = 0;
                    //set wave timer
                    gameObjectVars.timeUntilWave = 30;

                    //animate tray in
                    $("#controlTray").show('slide',{direction:'right'},1000);

                    //display wave count down
                    startWaveCounter();
                    //start ticks
                    gameObjectVars.runTick=false;
                    clockTick();
                }
                /**
                 * Starts wave countdown timer
                 * @author Ignacy Debicki
                 */
                function startWaveCounter(){
                    prepareWave();
                    $("#waveControls").velocity("slideDown",100,function(){setShopHeight();});
                    waveCountDown();
                    setShopHeight();
                }
                /**
                 * Updates countdown timer
                 * @author Ignacy Debicki
                 */
                function waveCountDown(){
                    $("#timeRemaining").html(gameObjectVars.timeUntilWave);
                    //decrement time if pause menu is not loaded
                    if ($("#pauseMenu").length == 0){
                        gameObjectVars.timeUntilWave--;
                    }


                    if (gameObjectVars.timeUntilWave>=0 && !gameObjectVars.stopWaveTimer){
                        setTimeout(waveCountDown,1000);
                    }else{
                        //reset
                        gameObjectVars.stopWaveTimer = false;
                        gameObjectVars.timeUntilWave = 30;

                        //time expired start wave
                        startWave(gameObjectVars.waveNo);
                        //hide countdown
                        $("#waveControls").velocity("slideUp",100,function(){setShopHeight();});
                        setShopHeight();
                    }
                }
                /**
                 * Executes schedualed event
                 * @author Ignacy Debicki
                 * @param {string} event Type of event
                 * @param {object} arg   Argument(s) for event 
                 */
                function executeEvent(event,arg){
                    switch(event){
                        case "ENABLE":
                            //is array of towers
                            for (var tower in arg){
                                if (arg.hasOwnProperty(tower)){
                                    //put tower into sideBar
                                    loadSideBarTower(arg[tower]);
                                }
                            }
                            break;
                        default:
                            console.error("invalid event");
                    }
                }
                /**
                 * Loads map into the game.
                 * @author Ignacy Debicki
                 * @param {object}  map              Map to load.
                 * @param {boolean} startImmediately If to start the game immediately after map load (Default true)
                 */
                function loadMap(map,startImmediately){
                    startImmediately = (typeof startImmediately === 'undefined') ? true : startImmediately;
                    setBaseHealth(map["maxBaseHealth"]);
                    changeHealth(map["startingBaseHealth"]);
                    startingResources =map["startingResources"];
                    setResources(map["startingResources"]);
                    gameObjectVars.mapID = map["id"];
                    gameObjectVars.mapPath = map["path"];
                    //calculate path for enemies and draw map divs so objects can interact with it
                    var vectorPath = calculateVectorPaths(gameObjectVars.mapPath,0,map["radius"]);
                    gameObjectVars.vectorPathRoot = vectorPath.root;
                    gameObjectVars.vectorPathRoot.setWeight();
                    //position base
                    var baseDiv = $('<div class="baseTile tile">');
                    $("#gameSpace").append(baseDiv);
                    baseDiv.css({left: map["baseLocation"][0] - 35, top: map["baseLocation"][1] - 35, width: map["baseRadius"]*2,height: map["baseRadius"]*2});
                    //set waves
                    gameObjectVars.waves = map["waves"];
                    //make sure all correct enemies are loaded
                    prepareWaves();
                    //set events
                    gameObjectVars.events = map["events"];
                    //make sure all correct towers are loaded in
                    prepareEvents();
                    //execute any events to be executed before start of clock   
                    if (gameObjectVars.events["pre"]){
                        var preEvents = gameObjectVars.events["pre"];
                        for (var event in preEvents){
                            if (gameObjectVars.events["pre"].hasOwnProperty(event)){
                                executeEvent(event,preEvents[event]);
                            }
                        }
                    }
                    if (startImmediately){
                        start();
                    }
                    
                }
                /**
                 * Creates vectorPathSegments and divs describing the path through the array of points
                 * @author Ignacy Debicki
                 * @param {Array}  points         Array of points
                 * @param {number} idOffset       Offset of vector id. (default 0)
                 * @param {numer}  pathRadius     The path radius
                 * @returns {object} The root object of the path and the last object of the path in format {'root':root,'last':lastSegments}
                 */
                function calculateVectorPaths(points,idOffset,pathRadius){
                    idOffset = typeof idOffset !== 'undefined' ? idOffset : 0;
                    var root = null;
                    var lastSegments = [];
                    for (var i=0;i<points.length-1;i++){
                        var id = idOffset*100+i;
                        var currentSegment = new VectorPathSegment();
                        var p1 = points[i].slice();
                        var p2 = points[i+1].slice();
                        
                        if (typeof(p1[0])=="number"){
                            if (typeof(p2[0])!=="number"){
                                p2 = p2[0].start;
                            }
                            parseElement({"x":p1[0],"y":p1[1]},{"x":p2[0],"y":p2[1]},2*pathRadius,pathRadius);
                            var vector = calculateVector(p1,p2);
                            currentSegment.x=vector.x;
                            currentSegment.y=vector.y;
                            currentSegment.m=vector.m;
                            currentSegment.id = id;
                            if (lastSegments.length==0){
                                root=currentSegment;
                            }else{
                                extendPath(lastSegments,currentSegment,1);
                            }
                        lastSegments=[currentSegment];
                        }else{
                            
                            //handle split
                            var start  = p1[0].start.slice();
                            var endingSegments = [];
                            for (var j = 1;j<p1.length;j++){
                                var pathProbability = p1[0]['p'+j];
                                var pointArray = [start.slice()];
                                pointArray = pointArray.concat(p1[j].slice());
                                pointArray.push(p2.slice());
                                var pathSegments = calculateVectorPaths(pointArray.slice(),idOffset+j,pathRadius);
                                
                                extendPath(lastSegments,pathSegments.root,pathProbability);
                                endingSegments = endingSegments.concat(pathSegments.last.slice());
                            }
                            lastSegments=endingSegments.slice();
                        }
                    }
                    return {'root':root,'last':lastSegments};
                }
                /**
                 * Extends the links of the vectorPathSegments to contain root with probability prob
                 * @author Ignacy Debicki
                 * @param {Array}  lastSegments Array of the vectorPathSegments to modify
                 * @param {object} root         vectorPathSegments to link
                 * @param {number} prob         Probability of the linked segment to be chosen (range: 0->1)
                 */
                function extendPath(lastSegments,root,prob){
                    for (var i = 0;i<lastSegments.length;i++){
                        var s = lastSegments[i];
                        s.addLink(root,prob);
                    }
                }
               
                /**
                 * Calculates the vector between two points
                 * @author Ignacy Debicki
                 * @param   {Array}  p1 Point specified by [x,y]
                 * @param   {Array}  p2 Point specified by [x,y]
                 * @returns {object} vector object with properties: x (unit vector in direction x (i)), y (unit vector in direction y (j)),m (magnitude of vector)
                 */
                function calculateVector(p1,p2){
                    var vector = {'x':(p2[0] - p1[0]),'y':(p2[1] - p1[1])};
                    vector.m = Math.sqrt(Math.pow(vector.x,2)+Math.pow(vector.y,2));
                    //obtain unit vector
                    vector.x/=vector.m;
                    vector.y/=vector.m;
                    return vector;
                }

                /**
                 * Creates and appends the path element to the game area.
                 * @author Ignacy Debicki
                 * @param {object} point               Point from in format {"x":x,"y":y}
                 * @param {object} nextPoint           Point to in format {"x":x,"y":y}
                 * @param {number} pathComponentHeight Height of the element
                 * @param {number} pathRadius          Half the width of the element
                 */
                function parseElement(point,nextPoint,pathComponentHeight,pathRadius){
                    
                    //always take smaller value of x and y
                    var pos = {};
                    var pointOrder = {'from':null,'to':null};
                    var horizontal={"x":1,"y":0};
                    if (point.x==nextPoint.x){
                        var minY = Math.min(point.y,nextPoint.y);
                        if (minY==point.y){
                            pointOrder.from=point;
                            pointOrder.to=nextPoint
                        }else{
                            pointOrder.from=nextPoint;
                            pointOrder.to=point;
                        }
                    }else{
                        var minX = Math.min(point.x,nextPoint.x);
                        if (minX==point.x){
                            pointOrder.from=point;
                            pointOrder.to=nextPoint
                        }else{
                            pointOrder.from=nextPoint;
                            pointOrder.to=point;
                        }
                    }
                    //work out angle between the two points
                    var angleFromHorizontal = Math.atan((pointOrder.to.y-pointOrder.from.y)/(pointOrder.to.x-pointOrder.from.x));
                    pos["x"] = pointOrder.from.x- pathRadius * Math.cos(angleFromHorizontal);
                    pos["y"] = pointOrder.from.y-pathRadius - pathRadius * Math.sin(angleFromHorizontal);
                    //use pythagoras to calculate length of div
                    var pathComponentWidth = magnitude({'x':pointOrder.to.x-pointOrder.from.x+2*pathRadius*Math.cos(angleFromHorizontal),'y':pointOrder.to.y-pointOrder.from.y+2*pathRadius*Math.sin(angleFromHorizontal)});

                    //add to layout
                    createPathElement({"width":pathComponentWidth,"height":pathComponentHeight},pos,angleFromHorizontal,pathRadius);
                }
                
                /**
                 * Returns the magnitude of an element
                 * @author Ignacy Debicki
                 * @param   {object} vector Vector object in format {"x":x,"y":y}
                 * @returns {number} Magnitue of vector
                 */
                function magnitude(vector){
                    return Math.pow(Math.pow(vector.x,2)+Math.pow(vector.y,2),0.5);
                }
                /**
                 * Creates a path element and appends to game area
                 * @author Ignacy Debicki
                 * @param {object} size       Size of element in format {"width":width,"height":height}
                 * @param {object} pos        Position of element in format {"x":x,"y":y}
                 * @param {number} angle      Angle from positive x axis the element is tilted at
                 * @param {number} pathRadius Radius of path (Circular ends)
                 */
                function createPathElement(size,pos,angle,pathRadius){
                    var gameContainer = $("#gameSpace")
                    var pathComponent = $(`
                        <div id="`+i+`" class="mapPathTile tile">
                            <div class="marker" id = "nw" style="left:`+pathRadius+`; top:0;"></div>
                            <div class="marker" id = "ne" style="right:`+pathRadius+`; top:0;"></div>
                            <div class="marker" id = "se" style="right:`+pathRadius+`; bottom:0;"></div>
                            <div class="marker" id = "sw" style="left:`+pathRadius+`; bottom:0;"></div>
                            <div class="marker" id = "cw" style="left:`+pathRadius+`; top:`+pathRadius+`;"></div>
                            <div class="marker" id = "ce" style="right:`+pathRadius+`; top:`+pathRadius+`;"></div>
                        </div>`);
                    gameContainer.append(pathComponent);
                    pathComponent.css({left: pos.x,
                                        top: pos.y,
                                        width:size.width,
                                        height: size.height,
                                        transform:"rotate("+angle+"rad)",
                                        borderRadius: pathRadius});
                }
                /**
                 * Parses events dictionary and loads in all necessary resources
                 * @author Ignacy Debicki
                 */
                function prepareEvents(){
                    for (var event in gameObjectVars.events) {
                        if (gameObjectVars.events.hasOwnProperty(event)){
                            for (var key in event) {
                                if (event.hasOwnProperty(key) && key =="ENABLE"){
                                    for (var tower in key){
                                        if (key.hasOwnProperty(tower)){
                                            loadTower(key[tower]);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                /**
                 * Parses waves dictionary and prepares all necessary resources
                 * @author Ignacy Debicki
                 */
                function prepareWaves(){
                    for (var waveKey in gameObjectVars.waves){
                        //make sure enemies are loaded for the wave
                        var wave = gameObjectVars.waves[waveKey];
                        if (gameObjectVars.waves.hasOwnProperty(waveKey)) { 
                            for (var tickKey in wave) {
                                if (wave.hasOwnProperty(tickKey)) { 
                                    var tick = wave[tickKey];
                                    for (var key in tick){
                                        if (tick.hasOwnProperty(key) && key != "delay") { 
                                            loadEnemy(key);
                                        }
                                    }
                                }
                            }
                        }
                    }

                }
                /**
                 * Scheduales enemies and events for wave
                 * @author Ignacy Debicki
                 */
                function prepareWave(){
                    //queue all enemy for wave
                    gameObjectVars.enemyQueue = {};
                    var delay = 1;
                    var wave = gameObjectVars.waves[gameObjectVars.waveNo];
                    for (var tickKey in wave) {
                        if (wave.hasOwnProperty(tickKey)) { 
                            var tick = wave[tickKey];
                            delay = parseInt(tick["delay"]);
                            for (var key in tick){
                                if (tick.hasOwnProperty(key) && key != "delay") { 
                                    for (var i = 0;i<tick[key];i++){
                                        var tickTrigger = parseInt(tickKey) + delay * i
                                        if (tickTrigger in gameObjectVars.enemyQueue){
                                            gameObjectVars.enemyQueue[tickTrigger].push({"enemy":loadEnemy(key)});
                                        }else{
                                            gameObjectVars.enemyQueue[tickTrigger]=[{"enemy":loadEnemy(key)}];
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                /**
                 * Starts the wave
                 * @author Ignacy Debicki
                 * @param {number} waveNo Identifier of wave to start
                 */
                function startWave(waveNo){
                    //start tick
                    gameObjectVars.clockTime=0;
                    gameObjectVars.runTick=true;
                }
                /**
                 * Attempts to upgrade the currently selected tower
                 * @author Ignacy Debicki
                 */
                function upgradeTower(){
                    $(".isSelected").each(function(i,e){
                        var currentSelection = $(".isSelected")[0];
                        var towerLevel = $(currentSelection).data("upgradeLevel");
                        var towerClass = $(currentSelection).data("towerClass");
                        if (towerLevel<gameObjectVars.towerDB[towerClass].length-1){
                            if(buyUpgrade()==true){
                                
                                var upgradeTowerData = gameObjectVars.towerDB[towerClass][towerLevel+1];
                                var currentRange = $(currentSelection).data("range");
                                var newRange = upgradeTowerData["range"];
                                var pos = {"x":$(currentSelection).css("left"),"y":$(currentSelection).css("top")};
                                if (currentRange!=newRange){
                                    var rangeDiff = newRange - currentRange;
                                    pos.x+=rangeDiff;
                                    pos.y+=rangeDiff;
                                }

                                var upgradeTowerDiv = upgradeTowerData["divBase"].clone();
                                $(upgradeTowerDiv).data("totalPrice", $(currentSelection).data("price") + $(upgradeTowerDiv).data("price"));
                                upgradeTowerDiv.css("top",pos.y)
                                                .css("left",pos.x);
                                $(currentSelection).remove();

                                $("#gameSpace").append(upgradeTowerDiv);
                                $(upgradeTowerDiv).children(".tower").click(selectTower);
                                $(upgradeTowerDiv).children(".tower").addClass("tile");
                                $(upgradeTowerDiv).children(".tower").trigger("click");
                                hideUpgradeStats();
                                if (towerLevel<1){
                                    showUpgradeStats();
                                }
                                

                            }else{
                                flashWarning("Not enough resources to buy upgrade");
                            }

                        }
                    });
                }
                /**
                 * Upgrades the currently selected tower
                 * @author Ignacy Debicki
                 * @returns {boolean} [[Description]]
                 */
                function buyUpgrade(){
                    var currentSelection = $(".isSelected")[0];
                    var towerLevel = $(currentSelection).data("upgradeLevel");
                    var towerClass = $(currentSelection).data("towerClass");
                    var upgradeTowerData = gameObjectVars.towerDB[towerClass][towerLevel+1];
                    if (gameObjectVars.resources-upgradeTowerData["cost"]>=0){
                        setResources(gameObjectVars.resources-upgradeTowerData["cost"]);
                        incrementStatistic("towersUpgraded");
                        gameObjectVars.score-=upgradeTowerData["score"];
                        return true;
                    }else{
                        return false;
                    }
                }
                /**
                 * Sells the currently selected tower and returns 75% of original resources, rounded down to nearest integer
                 * @author Ignacy Debicki
                 */
                function sellTower(){
                    $(".isSelected").each(function(i,e){
                        //return 75% of resources
                        setResources(gameObjectVars.resources+Math.floor($(this).data("totalPrice")*0.75));
                        //remove
                        $(this).remove();
                    });
                    removeTowerSelection();
                }
                /**
                 * Updates the displayed information about the selected tower
                 * @author Ignacy Debicki
                 */
                function updateActiveTowerInfo(){
                    $(".isSelected").each(function(i,e){
                        $("#activeTowerImage").attr("src",$(this).children(".tower").attr("src"));
                        $("#activeTowerAttack").html($(this).data("damage"));
                        $("#activeTowerRange").html($(this).data("range"));
                        $("#activeTowerCost").html(Math.floor($(this).data("totalPrice")*0.75));
                        $("#activeTowerReloadSpeed").html($(this).data("reloadSpeed"));
                        var towerLevel = $(this).data("upgradeLevel");
                        var towerClass = $(this).data("towerClass");
                        if (towerLevel>=gameObjectVars.towerDB[towerClass].length-1){
                            $("#upgradeTower").hide();
                        }else{
                            $("#upgradeTower").show();
                        }
                    });
                }
                /**
                 * Shows the stats for the tower if it were to be upgraded
                 * @author Ignacy Debicki
                 */
                function showUpgradeStats(){
                    var currentSelection = $(".isSelected")[0];
                    var towerLevel = $(currentSelection).data("upgradeLevel");
                    var towerClass = $(currentSelection).data("towerClass");
                    var upgradeTowerData = gameObjectVars.towerDB[towerClass][towerLevel+1];
                    $("#upgradeTowerAttack").html(upgradeTowerData["damage"]);
                    $("#upgradeTowerRange").html(upgradeTowerData["range"]);
                    $("#upgradeTowerReloadSpeed").html(upgradeTowerData["reloadSpeed"]);
                    $("#upgradeTowerCost").html(upgradeTowerData["cost"]);
                    $(".upgradeTowerInfo").css("display","inline-block");
                }
                /**
                 * Hides the stats for the tower if it were to be upgraded
                 * @author Ignacy Debicki
                 */
                function hideUpgradeStats(){
                    $(".upgradeTowerInfo").css("display","none");
                }
                /**
                 * Removes selection from currently selected tower
                 * @author Ignacy Debicki
                 */
                function removeTowerSelection(){
                    $(".isSelected").removeClass("isSelected");
                    $("#sideBarTowerControl").velocity("slideUp",100,function(){setShopHeight();});
                    setShopHeight();
                }
                
                function setShopHeight(){
                    var maxAvailableHeight = $("#controlTray").innerHeight() - $("#timeControls").outerHeight(true) - 70;
                    $("#controlTray").children(".sideBarDiv:not(#sideBarTowerSlots):visible").each(function(){
                        if ($(this).height()>0){
                            maxAvailableHeight-=parseFloat($(this).outerHeight(true));
                        }
                        
                    });
                    $("#sideBarTowerSlots").css("max-height",maxAvailableHeight);
                }
                /**
                 * Sets the new max health of the base
                 * @author Ignacy Debicki
                 * @param {number} newHealth New value of max health
                 */
                function setBaseHealth(newHealth){
                    gameObjectVars.maxHealth=newHealth;
                    $("#healthBar").progressbar( "option", "max", gameObjectVars.maxHealth );
                }
                /**
                 * Changes health to set health and checks if base has been destroyed
                 * @author Ignacy Debicki
                 * @param {number} health health to set value to, must be less than maxHealth
                 */
                function changeHealth(health){
                    gameObjectVars.baseHealth=health;
                    $("#healthValue").html(gameObjectVars.baseHealth);
                    $("#healthBar").progressbar("value",gameObjectVars.baseHealth);
                    if (gameObjectVars.baseHealth<=0){
                        gameObjectVars.stopTickFunction=true;
                        showEndGameScreen(getFinalScore());
                    }
                }
                /**
                 * Sets the amount of resources
                 * @author Ignacy Debicki
                 * @param {number} newResources The new amount of resources the player has
                 */
                function setResources(newResources){
                    $("#resourceValue").html(newResources);
                    gameObjectVars.resources= newResources;
                }
                /**
                 * Exits the currently running game
                 * @author Ignacy Debicki
                 */
                function exitGame(){
                    gameObjectVars.timeUntilWave=30;
                    gameObjectVars.runTick=false;
                    gameObjectVars.stopTickFunction=true;
                    gameObjectVars.stopWaveTimer=true;
                    $(".isDragging").each(function(i,e){
                        //refund resources
                        setResources(gameObjectVars.resources+$(this).data("price"));
                        //remove handlers
                        $('#gameSpace').unbind("");
                        //remove tower
                        $(this).remove();
                    });
                    $("#controlTray").show('slide',{direction:'right'},500,function(){
                        removeElement("mainGame");
                        showStartScreen();
                    });
                }
                /**
                 * Calculates path for enemy
                 * @author Ignacy Debicki
                 * @param   {number} x                  Current x position of enemy
                 * @param   {number} y                  Current y position of enemy
                 * @param   {object} currentVector      Vector the enemy is currently traversing (format {"x":x,"y":y,"m":m})
                 * @param   {number} movementRemaining  movment the enemy has left
                 * @param   {number} magnitudeRemaining The remaining length of the vector to be traversed
                 * @returns {object} New values for {"x":newX,"y":newY,"vector":newCurrentVector,"magnitudeRemaining":newMagnitudeRemaning}
                 */
                function calculatePath(x,y,currentVector,movementRemaining,magnitudeRemaining){
                    if (movementRemaining<=magnitudeRemaining){
                        x += currentVector.x*movementRemaining;
                        y += currentVector.y*movementRemaining;
                        magnitudeRemaining -=movementRemaining;
                    }else{
                        //reach end of path
                        x += currentVector.x*magnitudeRemaining;
                        y += currentVector.y*magnitudeRemaining;
                        
                        var nextVector = currentVector.next();
                        if(nextVector==null){
                            //return as at end anyway
                            magnitudeRemaining=0;
                        }else{
                            //more vector paths to calculate
                            //recalculate movementRemaining
                            movementRemaining -= magnitudeRemaining;
                            //recalculate magnitudeRemaining
                            magnitudeRemaining = nextVector.m;
                            return calculatePath(x,y,nextVector,movementRemaining,magnitudeRemaining);
                        }
                    }
                    return {
                        "x":x,
                        "y":y,
                        "vector":currentVector,
                        "magnitudeRemaining":magnitudeRemaining
                    };
                }
                /**
                 * Moves all enemies
                 * @author Ignacy Debicki
                 */
                function moveEnemies(){
                    $("#gameSpace .enemy").each(function(i,e){

                        //check collision with final base
                        if ($(this).data("currentVector").next()==null){
                            if (simpleSqCollision($(this),$(".baseTile"))){
                                dealBaseDamage($(this).data("damage"));
                                $(this).remove(); 
                                return;
                            }   
                        }
                        var returnData = calculatePath($(this).data("currentX"),
                                                        $(this).data("currentY"),
                                                        $(this).data("currentVector"),
                                                        $(this).data("speed"),
                                                        $(this).data("magnitudeRemaining")
                                                       );

                        $(this).data("currentVector",returnData.vector);
                        $(this).data("magnitudeRemaining",returnData.magnitudeRemaining);
                        $(this).data("currentX",returnData.x);
                        $(this).data("currentY",returnData.y);
                        var rotation = Math.round((Math.atan(returnData.vector.x/-returnData.vector.y))*(180/Math.PI));
                        if (returnData.vector.y>=0){ rotation += 180;}
                        $(this).animateRotate(rotation,gameObjectVars.baseClock/(gameObjectVars.clockMultiplier),"linear");
                        $(this).velocity({
                            left:returnData.x,
                            top: returnData.y,
                        },gameObjectVars.baseClock/gameObjectVars.clockMultiplier,"linear",{queue:false});
                        //increase no. of ticks survived
                        var ticks = $(this).data("ticks");
                        $(this).data("ticks", ticks+1);


                    });
                }
                
                /**
                 * Shoots projectiles from all towers that can shoot
                 * @author Ignacy Debicki
                 */
                function shootProjectiles(){
                    $("#gameSpace .towerContainer:not(.isDragging)").each(function(i,e){
                        var reloadState = $(this).data("reloadState");
                        reloadState+=1
                        //if reloaded, fire
                        if((reloadState % $(this).data("reloadSpeed")) == 0){
                            var targets = findTargets($(this));
                            if (targets!==null && targets!==undefined && targets!==[]){
                                for (var i =0;i<targets.length;i++){
                                    fireTower($(this),$(targets[i]));
                                }
                            }
                            reloadState=0;
                        }
                        $(this).data("reloadState",reloadState);

                    });
                }
                /**
                 * Performs game updates and updates in game tick
                 * @author Ignacy Debicki
                 */
                function clockTick(){
                    gameObjectVars.clockTickRunning=true;
                    //perform updates
                    if(gameObjectVars.runTick){
                        //spawn any new enemies in queue
                        spawnEnemy();
                        //check if projectiles collided with an enemy
                        checkProjectileCollisions();
                        //move enemies
                        moveEnemies();
                        //shoot projectiles
                        shootProjectiles();
                        //update the status of selected towers
                        updateActiveTowerInfo();
                        //update tick
                        gameObjectVars.clockTime++;
                    }
                    //schedual function with correct clock delay
                    if (gameObjectVars.clockMultiplier>0){
                        if (gameObjectVars.stopTickFunction==false){
                            //check if end of wave
                            if (endOfWave()&&gameObjectVars.runTick==true){
                                gameObjectVars.experienceGained+=20*gameObjectVars.experienceMultiplier;
                                updateLockedTowers();
                                //increment wave no
                                gameObjectVars.waveNo++;
                                if (gameObjectVars.waveNo>=gameObjectVars.waves.length){
                                    //alert("You have won!");
                                    showEndGameScreen(getFinalScore());
                                    gameObjectVars.stopTickFunction=true;
                                    gameObjectVars.runTick=false;
                                }else{
                                    //stop ticks
                                    gameObjectVars.runTick=false;
                                    gameObjectVars.clockTime=0;
                                    //start countdown
                                    startWaveCounter();
                                }
                            }
                            setTimeout(clockTick,gameObjectVars.baseClock/gameObjectVars.clockMultiplier);
                        }else{
                            gameObjectVars.stopTickFunction = false;
                        }
                    }else{
                        //display pause menu
                        gameObjectVars.clockTickRunning=false;
                        loadElement("gameComponents/pauseMenu.html","pauseMenu");
                    }
                }
                /**
                 * Tests wether the wave has ended
                 * @author Ignacy Debicki
                 * @returns {boolean} If the wave has ended
                 */
                function endOfWave(){
                    if (Object.size(gameObjectVars.enemyQueue)>0){
                        return false;
                    }
                    if ($(".enemy")[0]){
                        return false;
                    }
                    //all enemies from wave killed
                    return true;
                }
                /**
                 * Deals damage to the base
                 * @author Ignacy Debicki
                 * @param {number} damage Amount of damage dealt
                 */
                function dealBaseDamage(damage){
                    changeHealth(gameObjectVars.baseHealth-damage);
                }
                /**
                 * Changes game speed (duration between ticks)
                 * @author Ignacy Debicki
                 * @param {object} evt Event triggered by change speed button
                 */
                function changePlaybackTime(evt){
                    gameObjectVars.clockMultiplier = $(this).data("speed");
                    $(".selectedTimeControl").removeClass("selectedTimeControl");
                    $(this).addClass("selectedTimeControl");
                }

                /**
                 * Loads enemy resource into the enemy dictionary
                 * @author Ignacy Debicki
                 * @param   {string} enemyName Name of enemy to be loaded
                 * @returns {object} The enemies div template
                 */
                function loadEnemy(enemyName){
                    if ((enemyName in gameObjectVars.enemyDB)==false){
                        var data = window.gameCache.fetchFromCache("game,enemies,"+enemyName);
                        if (data === undefined){
                            data = $.ajax({
                                type: "GET",
                                url: "gameComponents/enemies/"+enemyName+".ed",
                                dataType: 'json',
                                async: false,
                                success: function(data) {}
                            });
                            window.gameCache.addToCache("game,enemies,"+enemyName,data);
                        }
                        data = data["responseJSON"];
                        var rotation = Math.round((Math.atan(gameObjectVars.vectorPathRoot.x/-gameObjectVars.vectorPathRoot.y))*(180/Math.PI));
                        if (gameObjectVars.vectorPathRoot.y>=0){ rotation += 180;}
                        
                        var enemyImg = $(`<img src='gameComponents/enemies/`+data["icon"]+`' 
                                            class='enemy ` + enemyName + `' 
                                            style='
                                                position: absolute;
                                                width:`+data["width"]+`px;
                                                height:`+data["height"]+`px;
                                                left:`+(gameObjectVars.mapPath[0][0]-(data["width"]/2))+`px;
                                                top:`+(gameObjectVars.mapPath[0][1]-(data["height"]/2))+`px;
                                                transform:rotate(`+rotation+`deg);'
                                            data-health='`+data["health"]+`' 
                                            data-damage='`+data["damage"]+`'
                                            data-speed='`+data["speed"]+`' 
                                            data-magnitude-remaining='`+gameObjectVars.vectorPathRoot.m+`' 
                                            data-current-x='`+(gameObjectVars.mapPath[0][0]-(data["width"]/2))+`' 
                                            data-current-y='`+(gameObjectVars.mapPath[0][1]-(data["height"]/2))+`' 
                                            data-resources='`+data["resources"]+`' 
                                            data-score='`+data["score"]+`'
                                            data-ticks='0'>`);
                        enemyImg.data("death",data["death"])
                        data["divBase"]=enemyImg;
                        gameObjectVars.enemyDB[enemyName]=data;
                        return enemyImg;
                    }else{
                        return gameObjectVars.enemyDB[enemyName]["divBase"];
                    }

                }
                /**
                 * Spawns any enemies awaiting to be spawned in the current tick in the enemyQueue
                 * @author Ignacy Debicki
                 */
                function spawnEnemy(){
                    if (gameObjectVars.enemyQueue[gameObjectVars.clockTime]){
                        for (var enemyDiv in gameObjectVars.enemyQueue[gameObjectVars.clockTime]){
                            if (gameObjectVars.enemyQueue[gameObjectVars.clockTime].hasOwnProperty(enemyDiv)){
                                var enemy = gameObjectVars.enemyQueue[gameObjectVars.clockTime][enemyDiv]["enemy"].clone(true)
                                var position = gameObjectVars.enemyQueue[gameObjectVars.clockTime][enemyDiv]["position"];
                                enemy.data("currentVector",gameObjectVars.vectorPathRoot);
                                $("#gameSpace").append(enemy);
                                if (position){
                                    var vector = gameObjectVars.enemyQueue[gameObjectVars.clockTime][enemyDiv]["vector"];
                                    var magnitudeRemaining = gameObjectVars.enemyQueue[gameObjectVars.clockTime][enemyDiv]["magnitudeRemaining"];
                                    enemy.css("left",position.left)
                                        .css("top",position.top)
                                        .data("magnitudeRemaining",magnitudeRemaining)
                                        .data("currentVector",vector)
                                        .data("currentX",position.left-enemy.width()/2)
                                        .data("currentY",position.top-enemy.height()/2);
                                }
                            }
                        }
                        delete gameObjectVars.enemyQueue[gameObjectVars.clockTime];
                    }

                }
                /**
                 * Loads a tower into the sidebar menu so it can be accessed
                 * @author Ignacy Debicki
                 * @param {string} towerName Name of tower to be loaded in
                 */
                function loadSideBarTower(towerName){
                    
                    var towerData = loadTower(towerName);
                    var baseTower = towerData["level"][0]
                    var towerDiv = baseTower["divBase"];
                    var towerSideBarImage = $("<img id='"+towerName+"' class='towerSideBarImage' src='gameComponents/towers/"+ baseTower["icon"] +"' >");
                    towerSideBarImage.data("divBase",towerDiv);
                    towerSideBarImage.data("cost",baseTower['cost']);
                    
                    
                    
                    var towerDescription = $(`<ul class='towerInfo'>
                                                <li>
                                                    <img class='sideBarStatImage' src='gameComponents/images/attack.png'>
                                                    <span class='sideBarStatText'>`+baseTower["damage"]+`</span>
                                                </li>
                                                <li>
                                                    <img class='sideBarStatImage' src='gameComponents/images/range.png'>
                                                    <span class='sideBarStatText'>`+baseTower["range"]+`</span>
                                                </li>
                                              </ul>
                                              <ul class='towerInfo'>
                                                <li>
                                                    <img class='sideBarStatImage' src='gameComponents/images/reload.png'>
                                                    <span class='sideBarStatText'>`+(baseTower['reloadSpeed'])+`</span>
                                                </li>
                                                <li>
                                                    <img class='sideBarStatImage' src='gameComponents/images/resources.png'>
                                                    <span class='sideBarStatText'>`+baseTower['cost']+`</span>
                                                </li>
                                               </ul>`);
                    var towerSideBarDiv = $("<div class='sideBarTowerDiv'>");
                    towerSideBarDiv.data("experience",towerData["experience"]);
                    if (window.login.isLoggedIn()){
                        if (gameObjectVars.experience>=towerData["experience"]){
                            towerSideBarImage.click(buyTower);
                        }else{
                            var cover = $(`<div class='sideBarTowerCover'>Need <span class="experienceValue">`+(towerData["experience"]-gameObjectVars.experience)+`</span> XP</div>`);
                            towerSideBarDiv.append(cover);
                            towerSideBarDiv.addClass("locked");
                        }
                    }else{
                        towerSideBarImage.click(buyTower);
                    }
                    towerSideBarDiv.append(towerSideBarImage)
                                    .append(towerDescription);

                    $("#sideBarTowerSlots").append(towerSideBarDiv);
                }
                /**
                 * Loads the tower resource and places it in the tower resource dictionary
                 * @author Ignacy Debicki
                 * @param   {string} towerName Name of tower to be loaded
                 * @returns {object} The template div for the tower
                 */
                function loadTower(towerName){
                    if ((towerName in gameObjectVars.towerDB)==false){
                        var data = window.gameCache.fetchFromCache("game,towers,"+towerName);
                        if (data ===undefined){
                            data = $.ajax({
                                type: "GET",
                                url: "gameComponents/towers/"+towerName+".td",
                                dataType: 'json',
                                async: false,
                                success: function(data) {}
                            })['responseJSON'];
                            window.gameCache.addToCache("game,towers,"+towerName,data);
                        } 
                        gameObjectVars.towerDB[towerName]=[];
                        for (i=0;i<data["level"].length;i++){
                            var towerLevelData = data["level"][i];
                            towerLevelData.experience = data["experience"];
                            var towerDiv = $(`<div class='`+towerName+i+` towerContainer' style='width:`+(towerLevelData["range"]*2)+`px; height:`+(towerLevelData["range"]*2)+`px;'
                                             data-width='`+data["width"]+`' 
                                             data-height='`+data["height"]+`' 
                                             data-reload-speed='`+towerLevelData["reloadSpeed"]+`' 
                                             data-projectile-fired='`+towerLevelData["projectileName"]+`' 
                                             data-no-projectiles-fired='`+towerLevelData["projectiles"]+`' 
                                             data-damage='`+towerLevelData["damage"]+`' 
                                             data-reload-state='0' 
                                             data-price='`+towerLevelData["cost"]+`' 
                                             data-total-price='`+towerLevelData["cost"]+`'
                                             data-range='`+towerLevelData["range"]+`' 
                                             data-upgrade-level='`+i+`'
                                             data-tower-class='`+towerName+`' 
                                             data-score-val='`+towerLevelData["score"]+`'>
                                             <div class='targetDisk `+towerName+i+`'></div>
                                            <img class='towerBase' src='gameComponents/towers/towerBase.png' style='width:`+data["width"]+`px; height:`+data["height"]+`px;left:`+(towerLevelData["range"]-data["width"]/2)+`px;top:`+(towerLevelData["range"]-data["height"]/2)+`px; position: absolute;'>
                                             <img class= 'tower `+towerName+i+`'
                                                src='gameComponents/towers/`+towerLevelData["icon"]+`' 
                                                style='width:`+data["width"]+`px; height:`+data["height"]+`px;left:`+(towerLevelData["range"]-data["width"]/2)+`px;top:`+(towerLevelData["range"]-data["height"]/2)+`px; position: absolute;'>
                                            </div>`);
                            towerLevelData["divBase"]=towerDiv;
                            gameObjectVars.towerDB[towerName][i]=towerLevelData;
                            loadProjectile(towerLevelData["projectileName"]);
                        }
                        return data;
                    }else{
                        return gameObjectVars.towerDB[towerName][0];
                    }
                }
                /**
                 * Attempts to buy tower
                 * @author Ignacy Debicki
                 */
                function buyTower(evt){
                    if ((gameObjectVars.resources>=$(this).data("cost")) && !$(".isDragging")[0]){
                        setResources(gameObjectVars.resources-$(this).data("cost"));
                        spawnTower($(this).data("divBase"));
                    }else{
                        flashWarning("Not enough resources or already bought tower");
                    }
                }
                /**
                 * Spawns tower in game area, and makes it follow the mouse. Sets necessary handers to place the tower down in a reasonable place.
                 * @author Ignacy Debicki
                 * @param   {object}  tower The tower div to be spawned
                 */
                function spawnTower(tower){
                    //remove selection of any previous tower
                    removeTowerSelection();
                    //spawn in new tower
                    var newTowerDiv = tower.clone();
                    newTowerDiv.addClass("isDragging");
                    $("#gameSpace").append(newTowerDiv);
                    gameObjectVars.currentDrag=newTowerDiv;
                    //move to current position of mouse
                    gameObjectVars.finalX = gameObjectVars.mousePos.x-$("#gameSpace").offset().left-newTowerDiv.outerHeight(false)/2;
                    gameObjectVars.finalY = gameObjectVars.mousePos.y-$("#gameSpace").offset().top-newTowerDiv.outerWidth(false)/2;
                    if (gameObjectVars.finalX<-(newTowerDiv.outerWidth(false)/2 - newTowerDiv.data("width")/2)){
                        gameObjectVars.finalX=-(newTowerDiv.outerWidth(false)/2 - newTowerDiv.data("width")/2);
                    }else if(gameObjectVars.finalX> $("#gameSpace").innerWidth()-3-(newTowerDiv.outerWidth(false)/2 + newTowerDiv.data("width")/2)){
                        gameObjectVars.finalX = $("#gameSpace").innerWidth()-3-(newTowerDiv.outerWidth(false)/2 + newTowerDiv.data("width")/2);
                    }
                    if (gameObjectVars.finalY<-(gameObjectVars.currentDrag.outerWidth(false)/2 - gameObjectVars.currentDrag.data("height")/2)){
                        gameObjectVars.finalY=-(gameObjectVars.currentDrag.outerWidth(false)/2 - gameObjectVars.currentDrag.data("height")/2);
                    }else if (gameObjectVars.finalY> $("#gameSpace").innerHeight()-(gameObjectVars.currentDrag.outerHeight(false)/2 + gameObjectVars.currentDrag.data("height")/2)){
                        gameObjectVars.finalY = $("#gameSpace").innerHeight()-(gameObjectVars.currentDrag.outerHeight(false)/2 + gameObjectVars.currentDrag.data("height")/2);
                    }
                    newTowerDiv.css("top",gameObjectVars.finalY)
                                .css("left",gameObjectVars.finalX);
                    //add handler for following mouse
                    $('#gameSpace').mousemove( function(e) {
                        gameObjectVars.mouseX = e.pageX; 
                        gameObjectVars.mouseY = e.pageY;
                        gameObjectVars.finalX = e.pageX-$("#gameSpace").offset().left-gameObjectVars.currentDrag.outerHeight(false)/2;
                        gameObjectVars.finalY = e.pageY-$("#gameSpace").offset().top-gameObjectVars.currentDrag.outerWidth(false)/2;
                        if (gameObjectVars.finalX<-(gameObjectVars.currentDrag.outerWidth(false)/2 - gameObjectVars.currentDrag.data("width")/2)){
                            gameObjectVars.finalX=-(gameObjectVars.currentDrag.outerWidth(false)/2 - gameObjectVars.currentDrag.data("width")/2);
                        }else if(gameObjectVars.finalX> $("#gameSpace").innerWidth()-3-(gameObjectVars.currentDrag.outerWidth(false)/2 + gameObjectVars.currentDrag.data("width")/2)){
                            gameObjectVars.finalX = $("#gameSpace").innerWidth()-3-(gameObjectVars.currentDrag.outerWidth(false)/2 + gameObjectVars.currentDrag.data("width")/2);
                        }
                        if (gameObjectVars.finalY<-(gameObjectVars.currentDrag.outerWidth(false)/2 - gameObjectVars.currentDrag.data("height")/2)){
                            gameObjectVars.finalY=-(gameObjectVars.currentDrag.outerWidth(false)/2 - gameObjectVars.currentDrag.data("height")/2);
                        }else if (gameObjectVars.finalY> $("#gameSpace").innerHeight()-(gameObjectVars.currentDrag.outerHeight(false)/2 + gameObjectVars.currentDrag.data("height")/2)){
                            gameObjectVars.finalY = $("#gameSpace").innerHeight()-(gameObjectVars.currentDrag.outerHeight(false)/2 + gameObjectVars.currentDrag.data("height")/2);
                        }
                        gameObjectVars.currentDrag.css("top",gameObjectVars.finalY)
                                    .css("left",gameObjectVars.finalX);
                        
                        $(".tile").each(function(i,e){
                            var colliding = false;
                            if (tileCollision($(this),gameObjectVars.currentDrag.children(".tower"))){
                                colliding = true
                                gameObjectVars.currentDrag.addClass("isColliding");
                                //break loop
                                return false;
                            }else if (i==$(".tile").length-1){
                                gameObjectVars.currentDrag.removeClass("isColliding");
                            }
                        });
                    }); 
                    $('#gameSpace').mousedown(placeTower);

                }
                /**
                 * Places the tower in the game area, if it is not colliding with any game tile.
                 * @author Ignacy Debicki
                 * @param {object} e Event triggered by the mouse being pressed to place it down
                 */
                function placeTower(e){
                    if (!(gameObjectVars.currentDrag.hasClass("isColliding"))){
                        //buy tower
                        $('#gameSpace').unbind("mousemove");
                        $('#gameSpace').unbind("mousedown",placeTower);
                        gameObjectVars.currentDrag.removeClass("isDragging");
                        gameObjectVars.currentDrag.children(".tower").click(selectTower);
                        //set tower as tile
                        gameObjectVars.score-=gameObjectVars.currentDrag.data("scoreVal");
                        gameObjectVars.currentDrag.children(".towerBase").addClass("tile");
                        gameObjectVars.currentDrag=null;
                        incrementStatistic("towersBuilt");
                        
                    }
                }
                /**
                 * Finds targets within range for tower to fire at
                 * @author Ignacy Debicki
                 * @param   {object} tower Tower to find target for (passed in as $(tower))
                 * @returns {Array} Array of enemies to fire at
                 */
                function findTargets(tower){
                    var targetingDisk = tower.children(".targetDisk");
                    var enemiesColliding = [];
                    $(".enemy").each(function(i,e){
                        if (crCollision(targetingDisk,$(this))==true){
                            if ( !$(this).data("damageToDeal")|| $(this).data("health")-$(this).data("damageToDeal")>0){
                                enemiesColliding.push(this);
                            }
                        }
                    });
                    if (enemiesColliding.length>0){
                        //rank enemies by distance travelled
                        enemiesColliding = rankByDistance(enemiesColliding);
                        //return array
                        var i =0;
                        while(enemiesColliding.length<tower.data("noProjectilesFired")){
                            enemiesColliding.push(enemiesColliding[i]);
                            i++;
                            if (i>=enemiesColliding.length){
                                i=0;
                            }
                        }
                        return enemiesColliding.slice(0,tower.data("noProjectilesFired"));
                    }else{
                        return [];
                    }
                }
                /**
                 * Selects a tower
                 * @author Ignacy Debicki
                 * @param {object} evt Event caused by pressing on tower
                 */
                function selectTower(evt){
                    removeTowerSelection();
                    $(this).parent().addClass("isSelected");
                    showTowerOverlay();
                    updateActiveTowerInfo();
                }
                /**
                 * Shows the tower information overlay in the sidebar menu
                 * @author Ignacy Debicki
                 */
                function showTowerOverlay(){
                    $("#sideBarTowerControl").velocity("slideDown",100,function(){setShopHeight();});
                    setShopHeight();
                }
                    
                /**
                 * Fires a projectile rom the tower towards the target
                 * @author Ignacy Debicki
                 * @param {object} tower  Tower that is to be fired (passed in as $(tower))
                 * @param {object} target Enemy the projectile is to be fired at (passed in as $(target))
                 */
                function fireTower(tower,target){
                    var projectileName = tower.data("projectileFired");
                    var projectileDiv = loadProjectile(projectileName).clone();
                    var projectileSpeed = projectileDiv.data("speed");
                    incrementStatistic("projectilesFired");
                    //set damage of tower
                    projectileDiv.data("damage",tower.data("damage"));
                    target.data("damageToDeal",tower.data("damage"));
                    projectileDiv.data("target",target);
                    //calculate flight path of projectile
                    var targetPosition = {"x":target.data("currentX")+target.outerWidth(false)/2,
                                          "y":target.data("currentY")+target.outerHeight(false)/2};
                    var startPosition = {"x":tower.children(".tower").offset().left-$("#gameSpace").offset().left+tower.children(".tower").outerWidth(false)/2,
                                         "y":tower.children(".tower").offset().top-$("#gameSpace").offset().top+tower.children(".tower").outerHeight(false)/2};
                    var rotation = Math.round((Math.atan((targetPosition.x-startPosition.x)/-(targetPosition.y-startPosition.y)))*(180/Math.PI));
                    if ((targetPosition.y-startPosition.y)>=0){ rotation += 180;}
                    //rotate tower
                    tower.children(".tower").animateRotate(rotation,gameObjectVars.baseClock/(gameObjectVars.clockMultiplier*4),"linear");
                    //spawn projectile
                    $("#gameSpace").append(projectileDiv);
                    projectileDiv.animateRotate(rotation,gameObjectVars.baseClock/(gameObjectVars.clockMultiplier*4),"linear");
                    projectileDiv.css({left: startPosition.x,
                                        top: startPosition.y});
                    projectileDiv.velocity({
                        top:targetPosition.y,
                        left:targetPosition.x
                    },gameObjectVars.baseClock/gameObjectVars.clockMultiplier,"linear",{queue:false});
                }
                /**
                 * Checks if a projectile has collided with an enemy and delas damage as necessary
                 * @author Ignacy Debicki
                 */
                function checkProjectileCollisions(){
                    $(".projectile").each(function(){
                        var damage = $(this).data("damage");
                        var target = $(this).data("target");
                        $(this).remove();
                        var targetHealth = target.data("health");
                        targetHealth-=damage;
                        if (targetHealth<=0){
                            enemyKilled(target);
                        }else{
                            target.data("health",targetHealth);
                            var damageToDeal =target.data("damageToDeal")
                            target.data("damageToDeal",damageToDeal-damage);
                        }
                    })
                }
                /**
                 * Kills an enemy and grants the appropriate number of resources to the player
                 * @author Ignacy Debicki
                 * @param {object} enemy The enemy to be killed (passed in as $(enemy))
                 */
                function enemyKilled(enemy){
                    incrementStatistic("enemiesKilled");
                    gameObjectVars.experienceGained+=gameObjectVars.experienceMultiplier;
                    updateLockedTowers();
                    setResources(gameObjectVars.resources+enemy.data("resources"));
                    gameObjectVars.score+=enemy.data("score");
                    var deathEvent = enemy.data("death");
                    if (deathEvent!=="" && deathEvent!==null && deathEvent!==undefined){
                        for (var event in deathEvent){
                            if (deathEvent.hasOwnProperty(event)){
                                switch(event){
                                    case "SPAWN":
                                        var spawnLocation = {"left":enemy.data("currentX")+enemy.width()/2, "top":enemy.data("currentY")+enemy.height()/2};
                                        for (var enemyToSpawn in deathEvent[event]){
                                            if (deathEvent[event].hasOwnProperty(enemyToSpawn)){
                                                var noToSpawn = deathEvent[event][enemyToSpawn];
                                                for (var i =0;i<noToSpawn;i++){
                                                    var tickTrigger = gameObjectVars.clockTime + 1 + i;
                                                    var dic = {"enemy":loadEnemy(enemyToSpawn), "position":spawnLocation,"vector":enemy.data("currentVector"),"magnitudeRemaining":enemy.data("magnitudeRemaining")};
                                                    if (tickTrigger in gameObjectVars.enemyQueue){   
                                                        gameObjectVars.enemyQueue[tickTrigger].push(dic);
                                                    }else{
                                                        gameObjectVars.enemyQueue[tickTrigger]=[dic];
                                                    }
                                                }
                                            }
                                        }
                                        break;
                                }
                            }
                        }
                    }
                    enemy.remove();
                }
                
                /**
                 * Loads the projectile resource into the projectile resource dictionary
                 * @author Ignacy Debicki
                 * @param   {string} projectileName NAme of projectile to be loaded
                 * @returns {object} Projectile div template
                 */
                function loadProjectile(projectileName){
                    if ((projectileName in gameObjectVars.projectileDB)==false){
                        var data = window.gameCache.fetchFromCache("game,projectiles,"+projectileName);
                        if (data===undefined){
                            data = $.ajax({
                                type: "GET",
                                url: "gameComponents/projectiles/"+projectileName+".pd",
                                dataType: 'json',
                                async: false,
                                success: function(data) {}
                            })['responseJSON'];
                            window.gameCache.addToCache("game,projectiles,"+projectileName,data);
                        } 
                        var projectileDiv = $("<img class='projectile "+projectileName+"' style='height:"+data["height"]+"px; width:"+data["width"]+"px;' data-speed='"+data["speed"]+"' src='gameComponents/projectiles/"+data["icon"]+"'>");
                        data["divBase"]=projectileDiv;
                        gameObjectVars.projectileDB[projectileName]=data;
                        return projectileDiv;
                    }else{
                        return gameObjectVars.projectileDB[projectileName]["divBase"];
                    }
                }
                /**
                 * Displays a warning in the sidebar menu
                 * @author Ignacy Debicki
                 * @param {string} message  Text of warning to be displayed
                 * @param {number} duration Default 5000 Duration of warning in milliseconds
                 */
                function flashWarning(message,duration){
                    duration = typeof duration !== 'undefined' ? duration : 5000;
                    showWarning(message);
                    gameObjectVars.warningMessageTimeout = setTimeout(hideWarning,duration);
                }    
                /**
                 * Displays warning in sidebar
                 * @author Ignacy Debicki
                 * @param {string} message Content of warning
                 */
                function showWarning(message){
                    clearTimeout(gameObjectVars.warningMessageTimeout);
                    $("#warning").show();
                    $("#warningText").html(message);
                    setShopHeight();
                }
                /**
                 * Hides the warning from the sidebar menu
                 * @author Ignacy Debicki
                 */
                function hideWarning(){
                    $("#warning").hide();
                    $("#warningText").empty();
                    setShopHeight();
                }
                /**
                 * Calculates the final score
                 * @author Ignacy Debicki
                 * @returns {number} Final score
                 */
                function getFinalScore(){
                    return gameObjectVars.score + gameObjectVars.baseHealth*5;
                }
                /**
                 * Shows the endGameScreen
                 * @author Ignacy Debicki
                 */
                function showEndGameScreen(finalScore){
                    if (window.login.isLoggedIn()){
                        window.login.addExperience(Math.round(gameObjectVars.experienceGained));
                    }
                    
                    gameObjectVars.stopWaveTimer=true;
                    gameObjectVars.stopTickFunction=true;
                    loadElement("gameComponents/endGameScreen.html","endGameScreen",function(){
                                    window.endGameScreen.initialise(finalScore,gameObjectVars.mapID,gameObjectVars.statistics,gameObjectVars.valid);
                    });
                }
                /**
                 * Loads a game from a game save file
                 * @author Ignacy Debicki
                 * @param {object}   gameData A game save file
                 */
                function loadGame(gameData){
                    gameObjectVars.baseHealth = gameData["baseHealth"];
                    gameObjectVars.score = gameData["currentScore"];
                    gameObjectVars.resources = gameData["currentResources"];
                    setResources(gameObjectVars.resources);
                    changeHealth(gameObjectVars.baseHealth);
                    gameObjectVars.waveNo = gameData["wave"];
                    gameObjectVars.clockTime = gameData["tick"];
                    gameObjectVars.mapID = gameData["map"];
                    gameObjectVars.statistics = gameData["statistics"];
                    //spawn all towers
                    for (var i =0 ;i<gameData["towers"].length;i++){
                        var towerData = gameData["towers"][i];
                        var towerDiv = gameObjectVars.towerDB[towerData["type"]][towerData["upgradeLevel"]]["divBase"].clone();;
                        towerDiv.data("reloadState",towerData["reloadState"])
                                .data("totalPrice",towerData["totalPrice"])
                                .data("effects",towerData["effects"]);
                        towerDiv.children(".tower").click(selectTower)
                                                    .addClass("tile");
                        $("#gameSpace").append(towerDiv);
                        towerDiv.css({top: towerData["position"]["y"], left: towerData["position"]["x"]})
                    }
                    var vectorSegmentCache = {};
                    for (var i=0;i<gameData["enemies"].length;i++){
                        var enemyData = gameData["enemies"][i];
                        var enemyDiv = loadEnemy(enemyData["type"]).clone();
                        enemyDiv.data("ticks",enemyData["ticksAlive"])
                                .data("health",enemyData["healthRemaining"])
                                .data("currentX",enemyData["position"]["x"])
                                .data("currentY",enemyData["position"]["y"])
                                .data("effects",enemyData["effects"])
                                .data("magnitudeRemaining",enemyData["magnitudeRemaining"]);
                        
                        var currentVector = vectorSegmentCache[enemyData["currentVector"]];
                        if (!vectorSegmentCache[enemyData["currentVector"]]){
                            currentVector  = gameObjectVars.vectorPathRoot.findSegmentOfID(enemyData["currentVector"]);
                            vectorSegmentCache[enemyData["currentVector"]] = currentVector;
                        }
                        enemyDiv.data("currentVector",currentVector);
                        $("#gameSpace").append(enemyDiv);
                        enemyDiv.css({top:enemyData["position"]["y"], left:enemyData["position"]["x"], transform:"rotate( "+enemyData["rotation"]+"deg)"});
                    }
                    
                    //animate tray in
                    $("#controlTray").show('slide',{direction:'right'},1000);
                    if (typeof gameData["timeUntilNextWave"] === 'undefined'){
                        gameObjectVars.timeUntilWave = gameData["timeUntilWave"];
                        gameObjectVars.runTick = false;
                        gameObjectVars.stopWaveTimer = false;
                        gameObjectVars.clockTime = 0;
                        clockTick();
                        startWaveCounter();
                    }else{
                        $("#waveControls").velocity("slideUp",100);
                        prepareWave();
                        gameObjectVars.stopWaveTimer = false;
                        gameObjectVars.timeUntilWave = 30;
                        gameObjectVars.runTick = true;
                        gameObjectVars.clockMultiplier = 1;
                        for (var i =0;i<=gameObjectVars.clockTime;i++){
                            delete gameObjectVars.enemyQueue[i];
                        }
                        clockTick();
                    }
                    
                }
                
                
                return{
                    /**
                     * Starts the game clock
                     * @author Ignacy Debicki
                     */
                    clockTick: function(){
                        if (gameObjectVars.clockTickRunning==false){
                            clockTick();
                        }else{
                            //invalidate game as attempted to break it. Do not send high score, do not save.
                            gameObjectVars.valid=false;
                            console.error("Stop trying!");
                            flashWarning("Stop trying to cheat!");
                        }   
                    },
                    /**
                     * Test function. Wins but game is not valid
                     * @author Ignacy Debicki
                     * @param {number} score Score to pass
                     */
                    win:function(score){
                        gameObjectVars.stopWaveTimer=true;
                        gameObjectVars.stopTickFunction=true;
                        loadElement("gameComponents/endGameScreen.html","endGameScreen",function(){
                                        window.endGameScreen.initialise(score,gameObjectVars.mapID,{"enemiesKilled":1,"towersBuilt":2,"towersUpgraded":3,"projectilesFired":4},false);
                                    });
                    },
                    /**
                     * Loads a map into the game area
                     * @author Ignacy Debicki
                     * @param {object}  mapInfo          Description of map
                     * @param {boolean} startImmediately If to start the game immediately after loading map
                     */
                    setMap:function(mapInfo,startImmediately){
                        mapInfo["mapData"]["id"]=parseInt(mapInfo["id"]);
                        loadMap(mapInfo["mapData"],startImmediately);
                    },
                    /**
                     * Exits the current game
                     * @author Ignacy Debicki
                     */
                    exitGame: function(){
                        exitGame();
                    },
                    /**
                     * Shows the end game screen
                     * @author Ignacy Debicki
                     * @param {number} endScore The final score
                     */
                    showEndGameScreen: function(endScore){
                        if (!endScore){endScore=gameObjectVars.score;}
                        showEndGameScreen(endScore);
                    },
                    /**
                     * The mapID of the map curently being played
                     * @author Ignacy Debicki
                     * @returns {number} Id of map
                     */
                    mapID: function(){
                        return gameObjectVars.mapID;
                    },
                    /**
                     * Exports a game to an object which can be saved
                     * @author Ignacy Debicki
                     * @returns {object} A game save object
                     */
                    exportGame:function(){
                        var exportMap = {};
                        if (gameObjectVars.clockTime==0 && gameObjectVars.runTick == false){
                            //currently counting down
                            exportMap["timeUntilWave"] = gameObjectVars.timeUntilWave;
                        }
                        
                        $(".isDragging").each(function(i,e){
                            //refund resources
                            setResources(gameObjectVars.resources+$(this).data("price"));
                            //remove handlers
                            $('#gameSpace').unbind("");
                            //remove tower
                            $(this).remove();
                        });
                        
                        exportMap["map"] = gameObjectVars.mapID;
                        exportMap["difficulty"] = "normal";
                        exportMap["baseHealth"] = gameObjectVars.baseHealth;
                        exportMap["currentScore"] = gameObjectVars.score;
                        exportMap["currentResources"] = gameObjectVars.resources;
                        exportMap["wave"] = gameObjectVars.waveNo;
                        exportMap["towers"]  = [];
                        exportMap["tick"] = gameObjectVars.clockTime;
                        exportMap["statistics"] = gameObjectVars.statistics;
                        $(".towerContainer").each(function(n,e){
                            var towerObject = {};
                            towerObject["type"] = $(this).data("towerClass");
                            towerObject["upgradeLevel"] = $(this).data("upgradeLevel");
                            towerObject["reloadState"] = $(this).data("reloadState");
                            towerObject["position"] = {"x":$(this).position().left, "y":$(this).position().top};
                            towerObject["effects"] = [];
                            towerObject["totalPrice"] = $(this).data("totalPrice");
                            exportMap["towers"].push(towerObject);
                        });
                        exportMap["enemies"]=[];
                        $(".enemy").each(function(i,e){
                            var enemyObject = {};
                            var classList = $(this).attr('class').split(/\s+/);
                            $.each(classList, function(index, item) {
                                if (item !== 'enemy') {
                                    enemyObject["type"]=item;
                                    return false;
                                }
                            });
                            enemyObject["ticksAlive"] = $(this).data("ticks");
                            enemyObject["healthRemaining"]  = $(this).data("health");
                            enemyObject["position"] = {"x":$(this).data("currentX"),"y":$(this).data("currentY")};
                            enemyObject["effects"] = [];
                            enemyObject["magnitudeRemaining"] = $(this).data("magnitudeRemaining");
                            enemyObject["currentVector"]  = $(this).data("currentVector").getId();
                            enemyObject["rotation"] = getRotationDegrees($(this));
                            exportMap["enemies"].push(enemyObject);
                        });
                        return exportMap;
                    },
                    /**
                     * Loads a game from a save object
                     * @author Ignacy Debicki
                     * @param {object} gameData Save object
                     */
                    loadGame: function(gameData){
                        loadGame(gameData);
                    },
                    /**
                     * Cleans out session variables
                     * @author Ignacy Debicki
                     */
                    purge: function(){
                        gameObjectVars = undefined;
                        window.game = undefined;
                        $(document).unbind("");
                    }
                }
            }
            
            
        </script>
    </head>
    <body>
        <div id="controlTray">
            <div id="timeControls">
                <img class="timeControl" id="pause" data-speed="0" src="gameComponents/images/pause.png">
                <img class="timeControl" id="play0.5X" data-speed="0.5" src="gameComponents/images/halfPlay.png">
                <img class="timeControl selectedTimeControl" id="play1X" data-speed="1" src="gameComponents/images/play.png">
                <img class="timeControl" id="play2X" data-speed="2" src="gameComponents/images/ff2x.png">
                <img class="timeControl" id="play3X" data-speed="4" src="gameComponents/images/ff3x.png">
            </div> 
            <div class="sideBarDiv" id="waveControls">
                <img id="timeRemianingImage" src="gameComponents/images/timeRemaining.png">
                <span id="timeRemaining">30</span>
                <button id="startWave">Start wave</button>
            </div>
            <div class="sideBarDiv" id="healthStats">
                <img class="sideBarImage" id="healthImage" src="gameComponents/images/health.png">
                <span class="sideBarStatText" id="healthValue">100</span>
                <img class="sideBarImage" id="resourcesImage" src="gameComponents/images/resources.png">
                <span class="sideBarStatText" id="resourceValue">200</span>
                <div id="healthBar"></div>
            </div>
            <div class="sideBarDiv" id="warning">
                <span id="warningText"></span>
            </div>
            <div class="sideBarDiv" id="sideBarTowerControl">
                <span class="sideBarDivTitle">Tower info</span>
                <img id="activeTowerImage">
                <ul class='activeTowerInfo'>
                    <li>
                        <img class='sideBarActiveTowerStatImage' src='gameComponents/images/attack.png'>
                        <span class='sideBarActiveTowerStatText' id="activeTowerAttack">10</span>
                        <span class='sideBarActiveTowerStatText statModifier' id="statModifierAtttack">+3</span>
                    </li>
                    <li>
                        <img class='sideBarActiveTowerStatImage' src='gameComponents/images/range.png'>
                        <span class='sideBarActiveTowerStatText' id="activeTowerRange">10</span>
                        <span class='sideBarActiveTowerStatText statModifier' id="statModifierRange">+3</span>
                    </li>
                    <li>
                        <img class='sideBarActiveTowerStatImage' src='gameComponents/images/reload.png'>
                        <span class='sideBarActiveTowerStatText' id="activeTowerReloadSpeed">4</span>
                        <span class='sideBarActiveTowerStatText statModifier' id="statModifierReloadSpeed">+3</span>
                    </li>
                    <li>
                        <img class='sideBarActiveTowerStatImage' src='gameComponents/images/resources.png'>
                        <span class='sideBarActiveTowerStatText' id="activeTowerCost">10</span>
                        <span class='sideBarActiveTowerStatText statModifier' id="statModifierCost">+3</span>
                    </li>
                </ul>
                <ul class='upgradeTowerInfo'>
                    <li>
                        <img class='sideBarActiveTowerStatImage' src='gameComponents/images/attack.png'>
                        <span class='sideBarActiveTowerStatText' id="upgradeTowerAttack">+3</span>
                    </li>
                    <li>
                        <img class='sideBarActiveTowerStatImage' src='gameComponents/images/range.png'>
                        <span class='sideBarActiveTowerStatText' id="upgradeTowerRange">+3</span>
                    </li>
                    <li>
                        <img class='sideBarActiveTowerStatImage' src='gameComponents/images/reload.png'>
                        <span class='sideBarActiveTowerStatText' id="upgradeTowerReloadSpeed">+2</span>
                    </li>
                    
                </ul>
                <div id="activeTowerButtons">
                    <button class="sideBarTowerButton" id="sellTower">Sell</button>
                    <button class="sideBarTowerButton" id="upgradeTower">Upgrade</button>
                    <span class='upgradeTowerInfo'>
                        <img class="sideBarUpgradeTowerStatImage" src='gameComponents/images/resources.png'>
                        <span id="upgradeTowerCost">60</span>
                    </span>
                </div>
                
            </div>
            <div class="sideBarDiv" id="sideBarTowerSlots">
                <span class="sideBarDivTitle">Buy towers</span>
            </div>
        </div>
        <div id="gameSpace">
        </div>
    </body>
</html>