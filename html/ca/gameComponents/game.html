<html>
    <head>
        <link rel="stylesheet" type="text/css" href="gameComponents/game.css">
        <script>
            
            window.game=(function(){
                /**
                 * Creates a new VectorPathSegment object
                 * @author Ignacy Debicki
                 * @constructor
                 * @param {number} x         X (i) value of unit vector direction
                 * @param {number} y         Y (j) value of unit vector direction
                 * @param {number} magnitude Length of vector
                 * @param {Array}  links     Array of vectors which directly follow on from current vector.
                 *                           Has form of [{'segment' : nextVectorPathSegment, 'p' : probabilityForVectorSelection}]
                 * @param {number} id        Identifier of the vector
                 */
                function VectorPathSegment(x,y,magnitude,links,id){
                    this.x = typeof x !== 'undefined' ? x : null;
                    this.y = typeof y !== 'undefined' ? y : null;
                    this.m = typeof magnitude !== 'undefined' ? magnitude : null;
                    this.links = typeof links !== 'undefined' ? links : [];
                    this.id = typeof id !== 'undefined' ? id : null;
                }
                    
                VectorPathSegment.prototype = {
                    /**
                     * Randomly chooses and returns the next segment from this segments segment links. Returns null if no next segment exists.
                     * @author Ignacy Debicki
                     * @returns {object} Reference to next vectorPathSegment or null if no next vectorPathSegment exists.
                     */
                    next: function(){
                        if (this.links.length==1){
                            return this.links[0].segment;
                        }else if(this.links.length==0){
                            return null;
                        }else{
                            //more than one
                            var p = this.links[0].p;
                            var rand = Math.random();
                            var link = 0;
                            while (rand>p){
                                link++;
                                p+=this.links[link].p;
                            }
                            return this.links[link].segment;
                        }
                    },
                    /**
                     * Adds a new link to the vectorPathSegment
                     * @author Ignacy Debicki
                     * @param {object} segment     vectorPathSegment to create a new link to
                     * @param {number} probability Probability this segment will be returned as the next segment (range: 0->1);
                     */
                    addLink: function(segment,probability){
                        this.links.push({'segment':segment,'p':probability});
                    },
                    /**
                     * Gets the ID of a segment
                     * @author Ignacy Debicki
                     * @returns {number} Id of the segment
                     */
                    getId: function(){
                        return this.id;
                    },
                    /**
                     * Sets the ID of a segment
                     * @author Ignacy Debicki
                     * @param {number} newID The new id to be set
                     */
                    setId: function(newID){
                        this.id = newID;
                    },
                    /**
                     * Finds a segment of a specific ID
                     * @author Ignacy Debicki
                     * @param   {id} id Id of segment to find
                     * @returns {object} Returns either false if the segment was not found, or a VectorPathSegment if found
                     */
                    findSegmentOfID: function(id){
                        if(this.id==id){
                            return this;
                        }else if (this.links.length > 0){
                            for (var i = 0; i < this.links.length; i++){
                                var segment = this.links[i].segment.findSegmentOfID(id);
                                if (segment!==false){
                                    return segment;
                                }
                            }
                            return false;
                        }else{
                            return false;
                        }
                    }
                };
                /**
                 * Bounding box collision test - does not account for rotation
                 * @author Ignacy Debicki
                 * @param   {object}  e1 Element to test (given already as $(element))
                 * @param   {object}  e2 Element to test (given already as $(element))
                 * @returns {boolean} If collision has occured
                 */
                function simpleSqCollision(e1, e2) {
                      var x1 = e1.offset().left;
                      var y1 = e1.offset().top;
                      var h1 = e1.outerHeight(true);
                      var w1 = e1.outerWidth(true);
                      var b1 = y1 + h1;
                      var r1 = x1 + w1;
                      var x2 = e2.offset().left;
                      var y2 = e2.offset().top;
                      var h2 = e2.outerHeight(true);
                      var w2 = e2.outerWidth(true);
                      var b2 = y2 + h2;
                      var r2 = x2 + w2;

                      if (b1 < y2 || y1 > b2 || r1 < x2 || x1 > r2) return false;
                      return true;
                }
                /**
                 * Checks if an element has collided with a game tile
                 * @author Ignacy Debicki
                 * @param   {object}  tile   Tile to be tested. Should be passed in as $(tile)
                 * @param   {object}  object Object to be tested. Should be passed in as $(object)
                 * @returns {boolean} If collision occured
                 */
                function tileCollision(tile,object){
                    
                    if (tile.hasClass("mapPathTile")){
                        var sqPoints = [];
                        var crPoints = [];
                        var objectPoints = [];
                        sqPoints.push({'x':tile.children("#nw.marker").offset().left,
                                   'y':tile.children("#nw.marker").offset().top});
                        sqPoints.push({'x':tile.children("#ne.marker").offset().left,
                                       'y':tile.children("#ne.marker").offset().top});
                        sqPoints.push({'x':tile.children("#se.marker").offset().left,
                                       'y':tile.children("#se.marker").offset().top});
                        sqPoints.push({'x':tile.children("#sw.marker").offset().left,
                                       'y':tile.children("#sw.marker").offset().top});

                        crPoints.push({'x':tile.children("#cw.marker").offset().left,
                                       'y':tile.children("#cw.marker").offset().top,
                                       'r':pathRadius});
                        crPoints.push({'x':tile.children("#ce.marker").offset().left,
                                       'y':tile.children("#ce.marker").offset().top,
                                       'r':pathRadius});

                        objectPoints.push({'x':object.offset().left,
                                           'y':object.offset().top});
                        objectPoints.push({'x':object.offset().left + object.outerWidth(),
                                           'y':object.offset().top});
                        objectPoints.push({'x':object.offset().left + object.outerWidth(),
                                           'y':object.offset().top + object.outerHeight()});
                        objectPoints.push({'x':object.offset().left,
                                           'y':object.offset().top + object.outerHeight()});
                    
                    return (advancedSqCollision(sqPoints,objectPoints) || circleSqCollision(crPoints[0],objectPoints) || circleSqCollision(crPoints[1],objectPoints));
                        
                    }else{
                        return simpleSqCollision(tile,object);
                    }
                    
                    
                }
                /**
                 * Tests the collision of a cirle element with a rectangular element
                 * @author Ignacy Debicki
                 * @param   {object}  circle Reference to circle object. Should be passed in as $(circle)
                 * @param   {array}  square Reference to corner points of rectangle.
                 * @returns {boolean} If collision occured
                 */
                function circleSqCollision(circle,square){
                    
                    for (var i = 0; i<3;i++){
                        var A = square[i];
                        var B = square[i+1];
                        if (crLineCollision(circle,[A,B])==true){
                            return true
                        }
                    }
                    return false
                }
                /**
                 * Tests for collision of line with circle
                 * @author Ignacy Debicki
                 * @param   {object}  circle     Circle element. Should be passed in as $(circle)
                 * @param   {Array}   linePoints Array of points that make up the line (A,B)
                 * @returns {boolean} IF collision occured
                 */
                function crLineCollision(circle,linePoints){
                    
                    if (Math.sqrt(Math.pow(linePoints[0].x-circle.x,2)+Math.pow(linePoints[0].y-circle.y,2))<circle.r ||
                        Math.sqrt(Math.pow(linePoints[1].x-circle.x,2)+Math.pow(linePoints[1].y-circle.y,2))<circle.r
                       ){
                        return true;
                    }
                    
                    var directionVector = {'x':(linePoints[0].x - linePoints[1].x),'y':(linePoints[0].y - linePoints[1].y)};
                    var magnitudeLimit = Math.sqrt(Math.pow(directionVector.x,2)+Math.pow(directionVector.y,2));
                    //obtain unit vector
                    directionVector.x/=magnitudeLimit;
                    directionVector.y/=magnitudeLimit;
                    var a = Math.pow(directionVector.x,2)+Math.pow(directionVector.y,2);
                    var b = 2*(directionVector.x*linePoints[0].x+directionVector.y*linePoints[0].y-circle.x*directionVector.x-circle.y*directionVector.y)
                    var c = Math.pow(circle.x,2)+ Math.pow(circle.y,2)+ Math.pow(linePoints[0].x,2)+ Math.pow(linePoints[0].y,2)- 2*(linePoints[0].x*circle.x+linePoints[0].y*circle.y)-Math.pow(circle.r,2);
                    
                    var determinant = Math.pow(b,2)-4*a*c;
                    if (determinant==0){
                        var lambda = Math.pow(b,2)/(2*a);
                        if (lambda<=magnitudeLimit && lambda >= 0){
                            return true;
                        }
                    }else if(determinant>0){
                        var lambda = [(Math.pow(b,2)-Math.sqrt(determinant))/(2*a),
                                      (Math.pow(b,2)+Math.sqrt(determinant))/(2*a)];
                        for (var i = 0;i<2;i++){
                            var l = lambda[i];
                            if (l<=magnitudeLimit && l >= 0){
                                return true;
                            }
                        }   
                    }
                    return false;
                }
                            
                /**
                 * Determines if two rectangles collide - with collision
                 * @author Ignacy Debicki
                 * @param   {object}  a Reference to object a. Should be passed in as $(a)
                 * @param   {object}  b Reference to object b. Should be passed in as $(b)
                 * @returns {boolean} If collision occured
                 */
                function advancedSqCollision (a, b) {

                    var polygons = [a, b];
                    var minA, maxA, projected, i, i1, j, minB, maxB;

                    for (i = 0; i < polygons.length; i++) {

                        // for each polygon, look at each edge of the polygon, and determine if it separates
                        // the two shapes
                        var polygon = polygons[i];
                        for (i1 = 0; i1 < polygon.length; i1++) {

                            // grab 2 vertices to create an edge
                            var i2 = (i1 + 1) % polygon.length;
                            var p1 = polygon[i1];
                            var p2 = polygon[i2];

                            // find the line perpendicular to this edge
                            var normal = { x: p2.y - p1.y, y: p1.x - p2.x };

                            minA = maxA = undefined;
                            // for each vertex in the first shape, project it onto the line perpendicular to the edge
                            // and keep track of the min and max of these values
                            for (j = 0; j < a.length; j++) {
                                projected = normal.x * a[j].x + normal.y * a[j].y;
                                if (minA===undefined || projected < minA) {
                                    minA = projected;
                                }
                                if (maxA===undefined || projected > maxA) {
                                    maxA = projected;
                                }
                            }

                            // for each vertex in the second shape, project it onto the line perpendicular to the edge
                            // and keep track of the min and max of these values
                            minB = maxB = undefined;
                            for (j = 0; j < b.length; j++) {
                                projected = normal.x * b[j].x + normal.y * b[j].y;
                                if (minB===undefined || projected < minB) {
                                    minB = projected;
                                }
                                if (maxB===undefined || projected > maxB) {
                                    maxB = projected;
                                }
                            }

                            // if there is no overlap between the projects, the edge we are looking at separates the two
                            // polygons, and we know there is no overlap
                            if (maxA < minB || maxB < minA) {
                                return false;
                            }
                        }
                    }
                    return true;
                };
                /**
                 * Simple circle - rectangle collision test - no rotation
                 * @author Ignacy Debicki
                 * @param   {object}  circle Reference to circle. Should be passed in as $(circle)
                 * @param   {object}  rect   Reference to rectangle. Should be passed in as $(rect)
                 * @returns {boolean} If collision occurs
                 */
                function crCollision(circle, rect) {
                    var cr = circle.outerWidth(true)/2;
                    var cx = circle.offset().left+cr;
                    var cy = circle.offset().top+cr;

                    var rx = rect.offset().left;
                    var ry = rect.offset().top;
                    var rh = rect.outerHeight(true);
                    var rw = rect.outerWidth(true);
                    var distX = Math.abs(cx - rx - rw / 2);
                    var distY = Math.abs(cy - ry - rh / 2);

                    if (distX > (rw / 2 + cr)) {
                        return false;
                    }
                    if (distY > (rh / 2 + cr)) {
                        return false;
                    }

                    if (distX <= (rw / 2)) {
                        return true;
                    }
                    if (distY <= (rh / 2)) {
                        return true;
                    }

                    var dx = distX - rw / 2;
                    var dy = distY - rh / 2;
                    return (dx * dx + dy * dy <= (cr * cr));
                }
                /**
                 * Ranks an arrau of enemy objects by the distance they have travelled
                 * @author Ignacy Debicki
                 * @param   {Array} enemies Array of enemy objects
                 * @returns {Array} Array of sorted by distance (Descending) enemies.
                 */
                function rankByDistance(enemies){
                    var distanceArray = [];
                    var enemyArray = [];
                    for (i=0;i<enemies.length;i++){
                        var enemy = enemies[i];
                        var distanceTravelled = $(enemy).data("ticks")*$(enemy).data("speed");
                        if (distanceArray.length>0){
                            for (j=0;j<distanceArray.length;j++){
                                if (distanceArray[j]<distanceTravelled){
                                    distanceArray.splice(j,0,distanceTravelled);
                                    enemyArray.splice(j,0,enemy);
                                    break;
                                }else if (j==distanceArray.length-1){
                                    distanceArray.push(distanceTravelled);
                                    enemyArray.push(enemy);
                                    break;
                                }
                            }
                        }else{
                            distanceArray.push(distanceTravelled);
                            enemyArray.push(enemy);
                        }

                    }
                    return enemyArray;
                }

                //init global vars
                var baseClock = 300;
                var clockMultiplier = 1;
                var prevClockMultiplier = 1;
                var clockTime = 0;
                //set constants
                var gameHeight = 675;
                var gameWidth = 875;
                var baseHealth = 100;
                var score = 0;
                var mapPath = [];
                var vectorPath = [];
                var vectorPathRoot = null;
                var pathRadius = 0;
                var towers = [];
                var stopTickFunction = false;
                var enemyQueue = {};
                var enemyDB = {};
                var towerDB = {};
                var projectileDB = {};
                var currentDrag = null;
                var mousePos = { x: 0, y: 0 };
                var maxHealth = 100;
                var resources = 0;
                var startingResources = 0;
                var waves = [];
                var waveNo = 0;
                var events = {};
                var timeUntilWave = 30;
                var stopWaveTimer = false
                var runTick = false;
                var pauseWaveTimer = false;
                var clockTickRunning=true;
                var valid = true;
                var warningMessageTimeout=null;
                var animationArray = [];
                var mapID = null;
                var statistics = {};
                
                $("document").ready(function(){
                    //set self to hidden
                    $("#controlTray").hide('fade',0,function(){
                        $("#controlTray").removeAttr("display");
                    });
                    $("#sideBarTowerControl").css("display","block");
                    $("#sideBarTowerControl").velocity("slideUp",0);
                    hideUpgradeStats();
                    hideWarning();
                    initiateStatistics();

                    //set handlers
                    $(".timeControl").click(changePlaybackTime);
                    $("#healthBar").progressbar({
                        disabled: false,
                        max: maxHealth,
                        value: baseHealth
                    })
                    $("#sellTower").click(sellTower);
                    $("#upgradeTower").click(upgradeTower);
                    $("#upgradeTower").hover(showUpgradeStats,hideUpgradeStats);
                    $("#startWave").click(function(){stopWaveTimer=true;});

                    $(document).mousemove(function(event) {
                        mousePos.x = event.pageX;
                        mousePos.y = event.pageY;
                    });
                    $("#gameSpace").mousedown(removeTowerSelection);
                });


                $(document).keyup(function(e) {
                    if (e.keyCode == 27) { 
                        // escape key pressed - if moving any tower, stop moving and refund
                        $(".isDragging").each(function(i,e){
                            //refund resources
                            setResources(resources+$(this).data("price"));
                            //remove handlers
                            $('#gameSpace').unbind("");
                            //remove tower
                            $(this).remove();
                        });
                    }
                });
                /**
                 * initiates all statistics to their initial values
                 * @author Ignacy Debicki
                 */
                function initiateStatistics(){
                    statistics["enemiesKilled"]=0;
                    statistics["towersBuilt"]=0;
                    statistics["towersUpgraded"]=0;
                    statistics["projectilesFired"]=0;
                }
                /**
                 * Increments the specified statistic
                 * @author Ignacy Debicki
                 * @param {string} statistic Options are: enemiesKilled, towersBuilt, towersUpgraded or projectilesFired
                 */
                function incrementStatistic(statistic){
                    statistics[statistic]++;
                }
                /**
                 * Starts the game tick and shows control elements
                 * @author Ignacy Debicki
                 */
                function start(){
                    //set wave number to 0
                    waveNo = 0;
                    //set wave timer
                    timeUntilWave = 30;

                    //animate tray in
                    $("#controlTray").show('slide',{direction:'right'},1000);

                    //display wave count down
                    startWaveCounter();
                    //start ticks
                    runTick=false;
                    clockTick();
                }
                /**
                 * Starts wave countdown timer
                 * @author Ignacy Debicki
                 */
                function startWaveCounter(){
                    prepareWave();
                    $("#waveControls").velocity("slideDown",100);
                    waveCountDown();
                }
                /**
                 * Updates countdown timer
                 * @author Ignacy Debicki
                 */
                function waveCountDown(){
                    $("#timeRemaining").html(timeUntilWave);
                    //decrement time if pause menu is not loaded
                    if ($("#pauseMenu").length == 0){
                        timeUntilWave--;
                    }


                    if (timeUntilWave>=0 && !stopWaveTimer){
                        setTimeout(waveCountDown,1000);
                    }else{
                        //reset
                        stopWaveTimer = false;
                        timeUntilWave = 30;

                        //time expired start wave
                        startWave(waveNo);
                        //hide countdown
                        $("#waveControls").velocity("slideUp",100);
                    }
                }
                /**
                 * Executes schedualed event
                 * @author Ignacy Debicki
                 * @param {string} event Type of event
                 * @param {object} arg   Argument(s) for event 
                 */
                function executeEvent(event,arg){
                    console.log(event,arg);
                    switch(event){
                        case "ENABLE":
                            //is array of towers
                            for (var tower in arg){
                                if (arg.hasOwnProperty(tower)){
                                    //put tower into sideBar
                                    loadSideBarTower(arg[tower]);
                                }
                            }
                            break;
                        default:
                            console.log("invalid event");
                    }
                }
                /**
                 * Loads map into the game.
                 * @author Ignacy Debicki
                 * @param {object}  map              Map to load.
                 * @param {boolean} startImmediately If to start the game immediately after map load (Default true)
                 */
                function loadMap(map,startImmediately){
                    startImmediately = (typeof startImmediately === 'undefined') ? true : startImmediately;
                    setBaseHealth(map["maxBaseHealth"]);
                    changeHealth(map["startingBaseHealth"]);
                    startingResources =map["startingResources"];
                    setResources(map["startingResources"]);
                    mapID = map["id"];
                    mapPath = map["path"];
                    //calculate path for enemies and draw map divs so objects can interact with it
                    vectorPathRoot = calculateVectorPaths(mapPath,0,map["radius"]).root;
                    //position base
                    var baseDiv = $('<div class="baseTile tile">');
                    $("#gameSpace").append(baseDiv);
                    baseDiv.css({left: map["baseLocation"][0] - 35, top: map["baseLocation"][1] - 35, width: map["baseRadius"]*2,height: map["baseRadius"]*2});
                    //set waves
                    waves = map["waves"];
                    //make sure all correct enemies are loaded
                    prepareWaves();
                    //set events
                    events = map["events"];
                    //make sure all correct towers are loaded in
                    prepareEvents();
                    //execute any events to be executed before start of clock   
                    if (events["pre"]){
                        var preEvents = events["pre"];
                        for (var event in preEvents){
                            if (events["pre"].hasOwnProperty(event)){
                                executeEvent(event,preEvents[event]);
                            }
                        }
                    }
                    if (startImmediately){
                        start();
                    }
                    
                }
                /**
                 * Creates vectorPathSegments and divs describing the path through the array of points
                 * @author Ignacy Debicki
                 * @param {Array}  points     Array of points
                 * @param {number} idOffset   Offset of vector id. (default 0)
                 * @param {numer}  pathRadius The path radius
                 * @returns {object} The root object of the path and the last object of the path in format {'root':root,'last':lastSegments}
                 */
                function calculateVectorPaths(points,idOffset,pathRadius){
                    idOffset = typeof idOffset !== 'undefined' ? idOffset : 0;
                    var root = null;
                    var lastSegments = [];
                    for (var i=0;i<points.length-1;i++){
                        var id = idOffset*100+i;
                        var currentSegment = new VectorPathSegment();
                        var p1 = points[i].slice();
                        var p2 = points[i+1].slice();
                        
                        if (typeof(p1[0])=="number"){
                            if (typeof(p2[0])!=="number"){
                                p2 = p2[0].start;
                            }
                            parseElement({"x":p1[0],"y":p1[1]},{"x":p2[0],"y":p2[1]},2*pathRadius,pathRadius);
                            var vector = calculateVector(p1,p2);
                            currentSegment.x=vector.x;
                            currentSegment.y=vector.y;
                            currentSegment.m=vector.m;
                            currentSegment.id = id;
                            if (lastSegments.length==0){
                                root=currentSegment;
                            }else{
                                extendPath(lastSegments,currentSegment,1);
                            }
                        lastSegments=[currentSegment];
                        }else{
                            
                            //handle split
                            var start  = p1[0].start.slice();
                            var endingSegments = [];
                            for (var j = 1;j<p1.length;j++){
                                var pathProbability = p1[0]['p'+j];
                                var pointArray = [start.slice()];
                                pointArray = pointArray.concat(p1[j].slice());
                                pointArray.push(p2.slice());
                                var pathSegments = calculateVectorPaths(pointArray.slice(),idOffset+j,pathRadius);
                                
                                extendPath(lastSegments,pathSegments.root,pathProbability);
                                endingSegments = endingSegments.concat(pathSegments.last.slice());
                            }
                            lastSegments=endingSegments.slice();
                        }
                    }
                    return {'root':root,'last':lastSegments};
                }
                /**
                 * Extends the links of the vectorPathSegments to contain root with probability prob
                 * @author Ignacy Debicki
                 * @param {Array}  lastSegments Array of the vectorPathSegments to modify
                 * @param {object} root         vectorPathSegments to link
                 * @param {number} prob         Probability of the linked segment to be chosen (range: 0->1)
                 */
                function extendPath(lastSegments,root,prob){
                    for (var i = 0;i<lastSegments.length;i++){
                        var s = lastSegments[i];
                        s.addLink(root,prob);
                    }
                }
                /**
                 * Calculates the vector between two points
                 * @author Ignacy Debicki
                 * @param   {Array}  p1 Point specified by [x,y]
                 * @param   {Array}  p2 Point specified by [x,y]
                 * @returns {object} vector object with properties: x (unit vector in direction x (i)), y (unit vector in direction y (j)),m (magnitude of vector)
                 */
                function calculateVector(p1,p2){
                    var vector = {'x':(p2[0] - p1[0]),'y':(p2[1] - p1[1])};
                    vector.m = Math.sqrt(Math.pow(vector.x,2)+Math.pow(vector.y,2));
                    //obtain unit vector
                    vector.x/=vector.m;
                    vector.y/=vector.m;
                    return vector;
                }

                /**
                 * Creates and appends the path element to the game area.
                 * @author Ignacy Debicki
                 * @param {object} point               Point from in format {"x":x,"y":y}
                 * @param {object} nextPoint           Point to in format {"x":x,"y":y}
                 * @param {number} pathComponentHeight Height of the element
                 * @param {number} pathRadius          Half the width of the element
                 */
                function parseElement(point,nextPoint,pathComponentHeight,pathRadius){
                    
                    //always take smaller value of x and y
                    var pos = {};
                    var pointOrder = {'from':null,'to':null};
                    var horizontal={"x":1,"y":0};
                    if (point.x==nextPoint.x){
                        var minY = Math.min(point.y,nextPoint.y);
                        if (minY==point.y){
                            pointOrder.from=point;
                            pointOrder.to=nextPoint
                        }else{
                            pointOrder.from=nextPoint;
                            pointOrder.to=point;
                        }
                    }else{
                        var minX = Math.min(point.x,nextPoint.x);
                        if (minX==point.x){
                            pointOrder.from=point;
                            pointOrder.to=nextPoint
                        }else{
                            pointOrder.from=nextPoint;
                            pointOrder.to=point;
                        }
                    }
                    console.log(pointOrder,pathComponentHeight,pathRadius);
                    //work out angle between the two points
                    var angleFromHorizontal = Math.atan((pointOrder.to.y-pointOrder.from.y)/(pointOrder.to.x-pointOrder.from.x));
                    console.log(angleFromHorizontal,"AFH");
                    pos["x"] = pointOrder.from.x- pathRadius * Math.cos(angleFromHorizontal);
                    pos["y"] = pointOrder.from.y-pathRadius - pathRadius * Math.sin(angleFromHorizontal);
                    //use pythagoras to calculate length of div
                    var pathComponentWidth = magnitude({'x':pointOrder.to.x-pointOrder.from.x+2*pathRadius*Math.cos(angleFromHorizontal),'y':pointOrder.to.y-pointOrder.from.y+2*pathRadius*Math.sin(angleFromHorizontal)});

                    //add to layout
                    createPathElement({"width":pathComponentWidth,"height":pathComponentHeight},pos,angleFromHorizontal,pathRadius);
                }
                
                /**
                 * Returns the magnitude of an element
                 * @author Ignacy Debicki
                 * @param   {object} vector Vector object in format {"x":x,"y":y}
                 * @returns {number} Magnitue of vector
                 */
                function magnitude(vector){
                    return Math.pow(Math.pow(vector.x,2)+Math.pow(vector.y,2),0.5);
                }
                /**
                 * Creates a path element and appends to game area
                 * @author Ignacy Debicki
                 * @param {object} size       Size of element in format {"width":width,"height":height}
                 * @param {object} pos        Position of element in format {"x":x,"y":y}
                 * @param {number} angle      Angle from positive x axis the element is tilted at
                 * @param {number} pathRadius Radius of path (Circular ends)
                 */
                function createPathElement(size,pos,angle,pathRadius){
                    console.log(size,pos,angle);
                    var gameContainer = $("#gameSpace")
                    var pathComponent = $(`
                        <div id="`+i+`" class="mapPathTile tile">
                            <div class="marker" id = "nw" style="left:`+pathRadius+`; top:0;"></div>
                            <div class="marker" id = "ne" style="right:`+pathRadius+`; top:0;"></div>
                            <div class="marker" id = "se" style="right:`+pathRadius+`; bottom:0;"></div>
                            <div class="marker" id = "sw" style="left:`+pathRadius+`; bottom:0;"></div>
                            <div class="marker" id = "cw" style="left:`+pathRadius+`; top:`+pathRadius+`;"></div>
                            <div class="marker" id = "ce" style="right:`+pathRadius+`; top:`+pathRadius+`;"></div>
                        </div>`);
                    gameContainer.append(pathComponent);
                    pathComponent.css({left: pos.x,
                                        top: pos.y,
                                        width:size.width,
                                        height: size.height,
                                        transform:"rotate("+angle+"rad)",
                                        borderRadius: pathRadius});
                }
                /**
                 * Parses events dictionary and loads in all necessary resources
                 * @author Ignacy Debicki
                 */
                function prepareEvents(){
                    for (var event in events) {
                        if (events.hasOwnProperty(event)){
                            for (var key in event) {
                                if (event.hasOwnProperty(key) && key =="ENABLE"){
                                    for (tower in key){
                                        if (key.hasOwnProperty(tower)){
                                            loadTower(key[tower]);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                /**
                 * Parses waves dictionary and prepares all necessary resources
                 * @author Ignacy Debicki
                 */
                function prepareWaves(){
                    for (var waveKey in waves){
                        //make sure enemies are loaded for the wave
                        var wave = waves[waveKey];
                        if (waves.hasOwnProperty(waveKey)) { 
                            for (var tickKey in wave) {
                                if (wave.hasOwnProperty(tickKey)) { 
                                    var tick = wave[tickKey];
                                    for (var key in tick){
                                        if (tick.hasOwnProperty(key) && key != "delay") { 
                                            loadEnemy(key);
                                        }
                                    }
                                }
                            }
                        }
                    }

                }
                /**
                 * Scheduales enemies and events for wave
                 * @author Ignacy Debicki
                 */
                function prepareWave(){
                    //queue all enemy for wave
                    enemyQueue = {};
                    var delay = 1;
                    var wave = waves[waveNo];
                    for (var tickKey in wave) {
                        if (wave.hasOwnProperty(tickKey)) { 
                            var tick = wave[tickKey];
                            delay = parseInt(tick["delay"]);
                            for (var key in tick){
                                if (tick.hasOwnProperty(key) && key != "delay") { 
                                    for (var i = 0;i<tick[key];i++){
                                        var tickTrigger = parseInt(tickKey) + delay * i
                                        if (tickTrigger in enemyQueue){
                                            enemyQueue[tickTrigger].push(loadEnemy(key));
                                        }else{
                                            enemyQueue[tickTrigger]=[loadEnemy(key)];
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                /**
                 * Starts the wave
                 * @author Ignacy Debicki
                 * @param {number} waveNo Identifier of wave to start
                 */
                function startWave(waveNo){
                    //start tick
                    clockTime=0;
                    runTick=true;
                }
                /**
                 * Attempts to upgrade the currently selected tower
                 * @author Ignacy Debicki
                 */
                function upgradeTower(){
                    $(".isSelected").each(function(i,e){
                        if ($(this).data("upgradeLevel")<2){
                            if(buyUpgrade()==true){
                                var currentSelection = $(".isSelected")[0];
                                var towerLevel = $(currentSelection).data("upgradeLevel");
                                var towerClass = $(currentSelection).data("towerClass");
                                var upgradeTowerData = towerDB[towerClass][towerLevel+1];
                                var currentRange = $(currentSelection).data("range");
                                var newRange = upgradeTowerData["range"];
                                var pos = {"x":$(currentSelection).css("left"),"y":$(currentSelection).css("top")};
                                if (currentRange!=newRange){
                                    var rangeDiff = newRange - currentRange;
                                    pos.x+=rangeDiff;
                                    pos.y+=rangeDiff;
                                }

                                var upgradeTowerDiv = upgradeTowerData["divBase"].clone();
                                $(upgradeTowerDiv).data("totalPrice", $(currentSelection).data("price") + $(upgradeTowerDiv).data("price"));
                                upgradeTowerDiv.css("top",pos.y)
                                                .css("left",pos.x);
                                $(currentSelection).remove();

                                $("#gameSpace").append(upgradeTowerDiv);
                                $(upgradeTowerDiv).children(".tower").click(selectTower);
                                $(upgradeTowerDiv).children(".tower").addClass("tile");
                                $(upgradeTowerDiv).children(".tower").trigger("click");
                                hideUpgradeStats();
                                if (towerLevel<1){
                                    showUpgradeStats();
                                }
                                

                            }else{
                                flashWarning("Not enough resources to buy upgrade");
                            }

                        }
                    });
                }
                /**
                 * Upgrades the currently selected tower
                 * @author Ignacy Debicki
                 * @returns {boolean} [[Description]]
                 */
                function buyUpgrade(){
                    var currentSelection = $(".isSelected")[0];
                    var towerLevel = $(currentSelection).data("upgradeLevel");
                    var towerClass = $(currentSelection).data("towerClass");
                    var upgradeTowerData = towerDB[towerClass][towerLevel+1];
                    if (resources-upgradeTowerData["cost"]>=0){
                        setResources(resources-upgradeTowerData["cost"]);
                        incrementStatistic("towersUpgraded");
                        score-=upgradeTowerData["score"];
                        return true;
                    }else{
                        return false;
                    }
                }
                /**
                 * Sells the currently selected tower and returns 75% of original resources, rounded down to nearest integer
                 * @author Ignacy Debicki
                 */
                function sellTower(){
                    $(".isSelected").each(function(i,e){
                        //return 75% of resources
                        setResources(resources+Math.floor($(this).data("totalPrice")*0.75));
                        //remove
                        $(this).remove();
                    });
                    removeTowerSelection();
                }
                /**
                 * Updates the displayed information about the selected tower
                 * @author Ignacy Debicki
                 */
                function updateActiveTowerInfo(){
                    $(".isSelected").each(function(i,e){
                        $("#activeTowerImage").attr("src",$(this).children("img").attr("src"));
                        $("#activeTowerAttack").html($(this).data("damage"));
                        $("#activeTowerRange").html($(this).data("range"));
                        $("#activeTowerCost").html(Math.floor($(this).data("totalPrice")*0.75));
                        $("#activeTowerReloadSpeed").html($(this).data("reloadSpeed"));
                        if ($(this).data("upgradeLevel")==2){
                            $("#upgradeTower").hide();
                        }else{
                            $("#upgradeTower").show();
                        }
                    });
                }
                /**
                 * Shows the stats for the tower if it were to be upgraded
                 * @author Ignacy Debicki
                 */
                function showUpgradeStats(){
                    var currentSelection = $(".isSelected")[0];
                    var towerLevel = $(currentSelection).data("upgradeLevel");
                    var towerClass = $(currentSelection).data("towerClass");
                    var upgradeTowerData = towerDB[towerClass][towerLevel+1];
                    $("#upgradeTowerAttack").html(upgradeTowerData["damage"]);
                    $("#upgradeTowerRange").html(upgradeTowerData["range"]);
                    $("#upgradeTowerReloadSpeed").html(upgradeTowerData["reloadSpeed"]);
                    $("#upgradeTowerCost").html(upgradeTowerData["cost"]);
                    $(".upgradeTowerInfo").css("display","inline-block");
                }
                /**
                 * Hides the stats for the tower if it were to be upgraded
                 * @author Ignacy Debicki
                 */
                function hideUpgradeStats(){
                    $(".upgradeTowerInfo").css("display","none");
                }
                /**
                 * Removes selection from currently selected tower
                 * @author Ignacy Debicki
                 */
                function removeTowerSelection(){
                    $(".isSelected").removeClass("isSelected");
                    $("#sideBarTowerControl").velocity("slideUp",100);
                }
                /**
                 * Sets the new max health of the base
                 * @author Ignacy Debicki
                 * @param {number} newHealth New value of max health
                 */
                function setBaseHealth(newHealth){
                    maxHealth=newHealth;
                    $("#healthBar").progressbar( "option", "max", maxHealth );
                }
                /**
                 * Changes health to set health and checks if base has been destroyed
                 * @author Ignacy Debicki
                 * @param {number} health health to set value to, must be less than maxHealth
                 */
                function changeHealth(health){
                    baseHealth=health;
                    $("#healthValue").html(baseHealth);
                    $("#healthBar").progressbar("value",baseHealth);
                    if (baseHealth<=0){
                        stopTickFunction=true;
                        showEndGameScreen(getFinalScore());
                    }
                }
                /**
                 * Sets the amount of resources
                 * @author Ignacy Debicki
                 * @param {number} newResources The new amount of resources the player has
                 */
                function setResources(newResources){
                    resources=newResources;
                    $("#resourceValue").html(resources);
                }
                /**
                 * Exits the currently running game
                 * @author Ignacy Debicki
                 */
                function exitGame(){
                    timeUntilWave=30;
                    runTick=false;
                    stopTickFunction=true;
                    stopWaveTimer=true;
                    $(".isDragging").each(function(i,e){
                        //refund resources
                        setResources(resources+$(this).data("price"));
                        //remove handlers
                        $('#gameSpace').unbind("");
                        //remove tower
                        $(this).remove();
                    });
                    $("#controlTray").show('slide',{direction:'right'},500,function(){
                        removeElement("mainGame");
                        showStartScreen();
                    });
                    window.game=null;
                }
                /**
                 * Calculates path for enemy
                 * @author Ignacy Debicki
                 * @param   {number} x                  Current x position of enemy
                 * @param   {number} y                  Current y position of enemy
                 * @param   {object} currentVector      Vector the enemy is currently traversing (format {"x":x,"y":y,"m":m})
                 * @param   {number} movementRemaining  movment the enemy has left
                 * @param   {number} magnitudeRemaining The remaining length of the vector to be traversed
                 * @returns {object} New values for {"x":newX,"y":newY,"vector":newCurrentVector,"magnitudeRemaining":newMagnitudeRemaning}
                 */
                function calculatePath(x,y,currentVector,movementRemaining,magnitudeRemaining){
                    if (movementRemaining<=magnitudeRemaining){
                        x += currentVector.x*movementRemaining;
                        y += currentVector.y*movementRemaining;
                        magnitudeRemaining -=movementRemaining;
                    }else{
                        //reach end of path
                        x += currentVector.x*magnitudeRemaining;
                        y += currentVector.y*magnitudeRemaining;
                        
                        var nextVector = currentVector.next();
                        if(nextVector==null){
                            //return as at end anyway
                            magnitudeRemaining=0;
                        }else{
                            //more vector paths to calculate
                            //recalculate movementRemaining
                            movementRemaining -= magnitudeRemaining;
                            //recalculate magnitudeRemaining
                            magnitudeRemaining = nextVector.m;
                            return calculatePath(x,y,nextVector,movementRemaining,magnitudeRemaining);
                        }
                    }
                    return {
                        "x":x,
                        "y":y,
                        "vector":currentVector,
                        "magnitudeRemaining":magnitudeRemaining
                    };
                }
                /**
                 * Moves all enemies
                 * @author Ignacy Debicki
                 */
                function moveEnemies(){
                    $("#gameSpace .enemy").each(function(i,e){

                        //check collision with final base
                        if ($(this).data("currentVector").next()==null){
                            if (simpleSqCollision($(this),$(".baseTile"))){
                                dealBaseDamage($(this).data("damage"));
                                $(this).remove(); 
                                return;
                            }   
                        }
                        var returnData = calculatePath($(this).data("currentX"),
                                                        $(this).data("currentY"),
                                                        $(this).data("currentVector"),
                                                        $(this).data("speed"),
                                                        $(this).data("magnitudeRemaining")
                                                       );

                        $(this).data("currentVector",returnData.vector);
                        $(this).data("magnitudeRemaining",returnData.magnitudeRemaining);
                        $(this).data("currentX",returnData.x);
                        $(this).data("currentY",returnData.y);

                        $(this).velocity({
                            left:returnData.x,
                            top: returnData.y,
                        },baseClock/clockMultiplier,"linear",{queue:false});
                        //increase no. of ticks survived
                        var ticks = $(this).data("ticks");
                        $(this).data("ticks", ticks+1);


                    });
                }
                
                /**
                 * Shoots projectiles from all towers that can shoot
                 * @author Ignacy Debicki
                 */
                function shootProjectiles(){
                    $("#gameSpace .towerContainer:not(.isDragging)").each(function(i,e){
                        var reloadState = $(this).data("reloadState");
                        reloadState+=1
                        //if reloaded, fire
                        if((reloadState % $(this).data("reloadSpeed")) == 0){
                            var target = findTarget($(this));
                            if (target!==null && target!==undefined && target!==[]){
                                fireTower($(this),$(target));
                            }
                            reloadState=0;
                        }
                        $(this).data("reloadState",reloadState);

                    });
                }
                /**
                 * Performs game updates and updates in game tick
                 * @author Ignacy Debicki
                 */
                function clockTick(){
                    clockTickRunning=true;
                    //perform updates
                    if(runTick){
                        //spawn any new enemies in queue
                        spawnEnemy();
                        //check if projectiles collided with an enemy
                        checkProjectileCollisions();
                        //move enemies
                        moveEnemies();
                        //shoot projectiles
                        shootProjectiles();
                        //update the status of selected towers
                        updateActiveTowerInfo();
                        //update tick
                        clockTime++;
                    }
                    //schedual function with correct clock delay
                    if (clockMultiplier>0){
                        if (stopTickFunction==false){
                            //check if end of wave
                            if (endOfWave()&&runTick==true){
                                //increment wave no
                                waveNo++;
                                if (waveNo>=waves.length){
                                    //alert("You have won!");
                                   showEndGameScreen(getFinalScore());
                                    stopTickFunction=true;
                                    runTick=false;
                                }else{
                                    //stop ticks
                                    runTick=false;
                                    clockTime=0;
                                    //start countdown
                                    startWaveCounter();
                                }
                            }
                            setTimeout(clockTick,baseClock/clockMultiplier);
                        }else{
                            stopTickFunction = false;
                        }
                    }else{
                        //display pause menu
                        clockTickRunning=false;
                        loadElement("gameComponents/pauseMenu.html","pauseMenu");
                    }
                }
                /**
                 * Tests wether the wave has ended
                 * @author Ignacy Debicki
                 * @returns {boolean} If the wave has ended
                 */
                function endOfWave(){
                    if (Object.size(enemyQueue)>0){
                        return false;
                    }
                    if ($(".enemy")[0]){
                        return false;
                    }
                    //all enemies from wave killed
                    return true;
                }
                /**
                 * Deals damage to the base
                 * @author Ignacy Debicki
                 * @param {number} damage Amount of damage dealt
                 */
                function dealBaseDamage(damage){
                    changeHealth(baseHealth-damage);
                }
                /**
                 * Changes game speed (duration between ticks)
                 * @author Ignacy Debicki
                 * @param {object} evt Event triggered by change speed button
                 */
                function changePlaybackTime(evt){
                    clockMultiplier = $(this).data("speed");
                    $(".selectedTimeControl").removeClass("selectedTimeControl");
                    $(this).addClass("selectedTimeControl");
                }

                /**
                 * Loads enemy resource into the enemy dictionary
                 * @author Ignacy Debicki
                 * @param   {string} enemyName NAme of enemy to be loaded
                 * @returns {object} The enemies div template
                 */
                function loadEnemy(enemyName){
                    if ((enemyName in enemyDB)==false){
                        var data = $.ajax({
                            type: "GET",
                            url: "gameComponents/enemies/"+enemyName+".ed",
                            dataType: 'json',
                            async: false,
                            success: function(data) {}
                        })['responseJSON'];
                        var enemyImg = $(`<img src='gameComponents/enemies/`+data["icon"]+`' 
                                            class='enemy ` + enemyName + `' 
                                            style='
                                                position: absolute;
                                                width:`+data["width"]+`px;
                                                height:`+data["height"]+`px;
                                                left:`+(mapPath[0][0]-(data["width"]/2))+`px;
                                                top:`+(mapPath[0][1]-(data["height"]/2))+`px;'
                                            data-health='`+data["health"]+`' 
                                            data-damage='`+data["damage"]+`' 
                                            data-death='`+data["death"]+`' 
                                            data-speed='`+data["speed"]+`' 
                                            data-magnitude-remaining='`+vectorPathRoot.m+`' 
                                            data-current-x='`+(mapPath[0][0]-(data["width"]/2))+`' 
                                            data-current-y='`+(mapPath[0][1]-(data["height"]/2))+`' 
                                            data-resources='`+data["resources"]+`' 
                                            data-score='`+data["score"]+`'
                                            data-ticks='0'>`);
                        data["divBase"]=enemyImg;
                        enemyDB[enemyName]=data;
                        return enemyImg;
                    }else{
                        return enemyDB[enemyName]["divBase"];
                    }

                }
                /**
                 * Spawns any enemies awaiting to be spawned in the current tick in the enemyQueue
                 * @author Ignacy Debicki
                 */
                function spawnEnemy(){
                    if (enemyQueue[clockTime]){
                        for (var enemyDiv in enemyQueue[clockTime]){
                            if (enemyQueue[clockTime].hasOwnProperty(enemyDiv)){
                                var enemy = enemyQueue[clockTime][enemyDiv].clone()
                                enemy.data("currentVector",vectorPathRoot);
                                $("#gameSpace").append(enemy);
                            }
                        }
                        delete enemyQueue[clockTime];
                    }

                }
                /**
                 * Loads a tower into the sidebar menu so it can be accessed
                 * @author Ignacy Debicki
                 * @param {string} towerName Name of tower to be loaded in
                 */
                function loadSideBarTower(towerName){
                    var towerData = loadTower(towerName);
                    var baseTower = towerData["level"][0]
                    var towerDiv = baseTower["divBase"];
                    var towerSideBarImage = $("<img id='"+towerName+"' class='towerSideBarImage' src='gameComponents/towers/"+ baseTower["icon"] +"' >");
                    towerSideBarImage.data("divBase",towerDiv);
                    towerSideBarImage.data("cost",baseTower['cost']);
                    towerSideBarImage.click(buyTower);
                    var towerDescription = $(`<ul class='towerInfo'>
                                                <li>
                                                    <img class='sideBarStatImage' src='gameComponents/images/attack.png'>
                                                    <span class='sideBarStatText'>`+baseTower["damage"]+`</span>
                                                </li>
                                                <li>
                                                    <img class='sideBarStatImage' src='gameComponents/images/range.png'>
                                                    <span class='sideBarStatText'>`+baseTower["range"]+`</span>
                                                </li>
                                              </ul>
                                              <ul class='towerInfo'>
                                                <li>
                                                    <img class='sideBarStatImage' src='gameComponents/images/reload.png'>
                                                    <span class='sideBarStatText'>`+(10-baseTower['reloadSpeed'])+`</span>
                                                </li>
                                                <li>
                                                    <img class='sideBarStatImage' src='gameComponents/images/resources.png'>
                                                    <span class='sideBarStatText'>`+baseTower['cost']+`</span>
                                                </li>
                                               </ul>`);
                    var towerSideBarDiv = $("<div class='sideBarTowerDiv'>");
                    towerSideBarDiv.append(towerSideBarImage)
                                    .append(towerDescription);

                    $("#sideBarTowerSlots").append(towerSideBarDiv);
                }
                /**
                 * Loads the tower resource and places it in the tower resource dictionary
                 * @author Ignacy Debicki
                 * @param   {string} towerName Name of tower to be loaded
                 * @returns {object} The template div for the tower
                 */
                function loadTower(towerName){
                    if ((towerName in towerDB)==false){
                        var data = $.ajax({
                            type: "GET",
                            url: "gameComponents/towers/"+towerName+".td",
                            dataType: 'json',
                            async: false,
                            success: function(data) {}
                        })['responseJSON'];
                        towerDB[towerName]=[];
                        for (i=0;i<data["level"].length;i++){
                            var towerLevelData = data["level"][i];
                            var towerDiv = $(`<div class='`+towerName+i+` towerContainer' style='width:`+(towerLevelData["range"]*2)+`px; height:`+(towerLevelData["range"]*2)+`px;'
                                             data-width='`+data["width"]+`' 
                                             data-height='`+data["height"]+`' 
                                             data-reload-speed='`+towerLevelData["reloadSpeed"]+`' 
                                             data-projectile-fired='`+towerLevelData["projectileName"]+`' 
                                             data-no-projectiles-fired='`+towerLevelData["projectiles"]+`' 
                                             data-damage='`+towerLevelData["damage"]+`' 
                                             data-reload-state='0' 
                                             data-price='`+towerLevelData["cost"]+`' 
                                             data-total-price='`+towerLevelData["cost"]+`'
                                             data-range='`+towerLevelData["range"]+`' 
                                             data-upgrade-level='`+i+`'
                                             data-tower-class='`+towerName+`' 
                                             data-score-val='`+towerLevelData["score"]+`'>
                                             <div class='targetDisk `+towerName+i+`'></div>
                                             <img class= 'tower `+towerName+i+`'
                                                src='gameComponents/towers/`+towerLevelData["icon"]+`' 
                                                style='width:`+data["width"]+`px; height:`+data["height"]+`px;left:`+(towerLevelData["range"]-data["width"]/2)+`px;top:`+(towerLevelData["range"]-data["height"]/2)+`px;'>
                                            </div>`);
                            towerLevelData["divBase"]=towerDiv;
                            towerDB[towerName][i]=towerLevelData;
                            loadProjectile(towerLevelData["projectileName"]);
                        }
                        return data;
                    }else{
                        return towerDB[towerName][0];
                    }
                }
                /**
                 * Attempts to buy tower
                 * @author Ignacy Debicki
                 * @param {[[Type]]} evt [[Description]]
                 */
                function buyTower(evt){
                    if ((resources>=$(this).data("cost")) && !$(".isDragging")[0]){
                        setResources(resources-$(this).data("cost"));
                        spawnTower($(this).data("divBase"));
                    }else{
                        flashWarning("Not enough resources or already bought tower");
                    }
                }
                /**
                 * Spawns tower in game area, and makes it follow the mouse. Sets necessary handers to place the tower down in a reasonable place.
                 * @author Ignacy Debicki
                 * @param   {object}  tower The tower div to be spawned
                 */
                function spawnTower(tower){
                    //remove selection of any previous tower
                    removeTowerSelection();
                    //spawn in new tower
                    var newTowerDiv = tower.clone();
                    newTowerDiv.addClass("isDragging");
                    $("#gameSpace").append(newTowerDiv);
                    currentDrag=newTowerDiv;
                    //move to current position of mouse
                    finalX = mousePos.x-$("#gameSpace").offset().left-newTowerDiv.outerHeight(false)/2;
                    finalY = mousePos.y-$("#gameSpace").offset().top-newTowerDiv.outerWidth(false)/2;
                    if (finalX<-(newTowerDiv.outerWidth(false)/2 - newTowerDiv.data("width")/2)){
                        finalX=-(newTowerDiv.outerWidth(false)/2 - newTowerDiv.data("width")/2);
                    }else if(finalX> $("#gameSpace").innerWidth()-3-(newTowerDiv.outerWidth(false)/2 + newTowerDiv.data("width")/2)){
                        finalX = $("#gameSpace").innerWidth()-3-(newTowerDiv.outerWidth(false)/2 + newTowerDiv.data("width")/2);
                    }
                    if (finalY<-(currentDrag.outerWidth(false)/2 - currentDrag.data("height")/2)){
                        finalY=-(currentDrag.outerWidth(false)/2 - currentDrag.data("height")/2);
                    }else if (finalY> $("#gameSpace").innerHeight()-(currentDrag.outerHeight(false)/2 + currentDrag.data("height")/2)){
                        finalY = $("#gameSpace").innerHeight()-(currentDrag.outerHeight(false)/2 + currentDrag.data("height")/2);
                    }
                    newTowerDiv.css("top",finalY)
                                .css("left",finalX);
                    //add handler for following mouse
                    $('#gameSpace').mousemove( function(e) {
                        mouseX = e.pageX; 
                        mouseY = e.pageY;
                        finalX = e.pageX-$("#gameSpace").offset().left-currentDrag.outerHeight(false)/2;
                        finalY = e.pageY-$("#gameSpace").offset().top-currentDrag.outerWidth(false)/2;
                        if (finalX<-(currentDrag.outerWidth(false)/2 - currentDrag.data("width")/2)){
                            finalX=-(currentDrag.outerWidth(false)/2 - currentDrag.data("width")/2);
                        }else if(finalX> $("#gameSpace").innerWidth()-3-(currentDrag.outerWidth(false)/2 + currentDrag.data("width")/2)){
                            finalX = $("#gameSpace").innerWidth()-3-(currentDrag.outerWidth(false)/2 + currentDrag.data("width")/2);
                        }
                        if (finalY<-(currentDrag.outerWidth(false)/2 - currentDrag.data("height")/2)){
                            finalY=-(currentDrag.outerWidth(false)/2 - currentDrag.data("height")/2);
                        }else if (finalY> $("#gameSpace").innerHeight()-(currentDrag.outerHeight(false)/2 + currentDrag.data("height")/2)){
                            finalY = $("#gameSpace").innerHeight()-(currentDrag.outerHeight(false)/2 + currentDrag.data("height")/2);
                        }
                        currentDrag.css("top",finalY)
                                    .css("left",finalX);
                        
                        $(".tile").each(function(i,e){
                            var colliding = false;
                            if (tileCollision($(this),currentDrag.children(".tower"))){
                                colliding = true
                                currentDrag.addClass("isColliding");
                                //break loop
                                return false;
                            }else if (i==$(".tile").length-1){
                                currentDrag.removeClass("isColliding");
                            }
                        });
                    }); 
                    $('#gameSpace').mousedown(placeTower);

                }
                /**
                 * Places the tower in the game area, if it is not colliding with any game tile.
                 * @author Ignacy Debicki
                 * @param {object} e Event triggered by the mouse being pressed to place it down
                 */
                function placeTower(e){
                    if (!(currentDrag.hasClass("isColliding"))){
                        //buy tower
                        $('#gameSpace').unbind("mousemove");
                        $('#gameSpace').unbind("mousedown",placeTower);
                        currentDrag.removeClass("isDragging");
                        currentDrag.children(".tower").click(selectTower);
                        //set tower as tile
                        score-=currentDrag.data("scoreVal");
                        currentDrag.children(".tower").addClass("tile");
                        currentDrag=null;
                        incrementStatistic("towersBuilt");
                        
                    }
                }
                /**
                 * Finds a target within range for tower to fire at
                 * @author Ignacy Debicki
                 * @param   {object} tower Tower to find target for (passed in as $(tower))
                 * @returns {object} Enemy to fire at, or null if no enemy fouund within range
                 */
                function findTarget(tower){
                    var targetingDisk = tower.children(".targetDisk");
                    var enemiesColliding = [];
                    $(".enemy").each(function(i,e){
                        if (crCollision(targetingDisk,$(this))==true){
                            enemiesColliding.push(this);
                        }
                    });
                    if (enemiesColliding.length>0){
                        //rank enemies by distance travelled
                        enemiesColliding = rankByDistance(enemiesColliding);
                        //shoot at first one
                        return enemiesColliding[0];
                    }else{
                        return null;
                    }
                }
                /**
                 * Selects a tower
                 * @author Ignacy Debicki
                 * @param {object} evt Event caused by pressing on tower
                 */
                function selectTower(evt){
                    removeTowerSelection();
                    $(this).parent().addClass("isSelected");
                    showTowerOverlay();
                    updateActiveTowerInfo();
                }
                /**
                 * Shows the tower information overlay in the sidebar menu
                 * @author Ignacy Debicki
                 */
                function showTowerOverlay(){
                    $("#sideBarTowerControl").velocity("slideDown",100);
                }
                /**
                 * Fires a projectile rom the tower towards the target
                 * @author Ignacy Debicki
                 * @param {object} tower  Tower that is to be fired (passed in as $(tower))
                 * @param {object} target Enemy the projectile is to be fired at (passed in as $(target))
                 */
                function fireTower(tower,target){
                    var projectileName = tower.data("projectileFired");
                    var projectileDiv = loadProjectile(projectileName).clone();
                    var projectileSpeed = projectileDiv.data("speed");
                    incrementStatistic("projectilesFired");
                    //set damage of tower
                    projectileDiv.data("damage",tower.data("damage"));
                    projectileDiv.data("target",target);
                    //calculate flight path of projectile
                    var targetPosition = {"x":target.data("currentX")+target.outerWidth(false)/2,
                                          "y":target.data("currentY")+target.outerHeight(false)/2};
                    var startPosition = {"x":tower.children(".tower").offset().left-$("#gameSpace").offset().left+tower.children(".tower").outerWidth(false)/2,
                                         "y":tower.children(".tower").offset().top-$("#gameSpace").offset().top+tower.children(".tower").outerHeight(false)/2};
                    //spawn projectile
                    $("#gameSpace").append(projectileDiv);
                    projectileDiv.css("left",startPosition.x)
                                    .css("top",startPosition.y);
                    projectileDiv.velocity({
                        top:targetPosition.y,
                        left:targetPosition.x
                    },baseClock/clockMultiplier,"linear",{queue:false});
                }
                /**
                 * Checks if a projectile has collided with an enemy and delas damage as necessary
                 * @author Ignacy Debicki
                 */
                function checkProjectileCollisions(){
                    $(".projectile").each(function(){
                        var damage = $(this).data("damage");
                        var target = $(this).data("target");
                        $(this).remove();
                        var targetHealth = target.data("health");
                        targetHealth-=damage;
                        if (targetHealth<=0){
                            enemyKilled(target);
                        }else{
                            target.data("health",targetHealth);
                        }
                    })
                }
                /**
                 * Kills an enemy and grants the appropriate number of resources to the player
                 * @author Ignacy Debicki
                 * @param {object} enemy The enemy to be killed (passed in as $(enemy))
                 */
                function enemyKilled(enemy){
                    incrementStatistic("enemiesKilled");
                    setResources(resources+enemy.data("resources"));
                    score+=enemy.data("score");
                    enemy.remove();
                }
                /**
                 * Loads the projectile resource into the projectile resource dictionary
                 * @author Ignacy Debicki
                 * @param   {string} projectileName NAme of projectile to be loaded
                 * @returns {object} Projectile div template
                 */
                function loadProjectile(projectileName){
                    if ((projectileName in projectileDB)==false){
                        var data = $.ajax({
                            type: "GET",
                            url: "gameComponents/projectiles/"+projectileName+".pd",
                            dataType: 'json',
                            async: false,
                            success: function(data) {}
                        })['responseJSON'];
                        var projectileDiv = $("<img class='projectile "+projectileName+"' style='height:"+data["height"]+"px; width:"+data["width"]+"px;' data-speed='"+data["speed"]+"' src='gameComponents/projectiles/"+data["icon"]+"'>");
                        data["divBase"]=projectileDiv;
                        projectileDB[projectileName]=data;
                        return projectileDiv;
                    }else{
                        return projectileDB[projectileName]["divBase"];
                    }
                }
                /**
                 * Displays a warning in the sidebar menu
                 * @author Ignacy Debicki
                 * @param {string} message  Text of warning to be displayed
                 * @param {number} duration Default 5000 Duration of warning in milliseconds
                 */
                function flashWarning(message,duration){
                    duration = typeof duration !== 'undefined' ? duration : 5000;
                    showWarning(message);
                    warningMessageTimeout = setTimeout(hideWarning,duration);
                }    
                /**
                 * Displays warning in sidebar
                 * @author Ignacy Debicki
                 * @param {string} message Content of warning
                 */
                function showWarning(message){
                    clearTimeout(warningMessageTimeout);
                    $("#warning").show();
                    $("#warningText").html(message);
                }
                /**
                 * Hides the warning from the sidebar menu
                 * @author Ignacy Debicki
                 */
                function hideWarning(){
                    $("#warning").hide();
                    $("#warningText").empty();
                }
                /**
                 * Calculates the final score
                 * @author Ignacy Debicki
                 * @returns {number} Final score
                 */
                function getFinalScore(){
                    return score + baseHealth*5;
                }
                /**
                 * Shows the endGameScreen
                 * @author Ignacy Debicki
                 */
                function showEndGameScreen(finalScore){
                    stopWaveTimer=true;
                    stopTickFunction=true;
                    loadElement("gameComponents/endGameScreen.html","endGameScreen",function(){
                                    window.endGameScreen.initialise(finalScore,mapID,statistics,valid);
                    });
                }
                /**
                 * Loads a game from a game save file
                 * @author Ignacy Debicki
                 * @param {object}   gameData A game save file
                 */
                function loadGame(gameData){
                    baseHealth = gameData["baseHealth"];
                    score = gameData["currentScore"];
                    resources = gameData["currentResources"];
                    setResources(resources);
                    changeHealth(baseHealth);
                    waveNo = gameData["wave"];
                    clockTime = gameData["tick"];
                    mapID = gameData["map"];
                    statistics = gameData["statistics"];
                    //spawn all towers
                    for (var i =0 ;i<gameData["towers"].length;i++){
                        var towerData = gameData["towers"][i];
                        var towerDiv = towerDB[towerData["type"]][towerData["upgradeLevel"]]["divBase"].clone();;
                        towerDiv.data("reloadState",towerData["reloadState"])
                                .data("totalPrice",towerData["totalPrice"])
                                .data("effects",towerData["effects"]);
                        towerDiv.children(".tower").click(selectTower)
                                                    .addClass("tile");
                        $("#gameSpace").append(towerDiv);
                        towerDiv.css({top: towerData["position"]["y"], left: towerData["position"]["x"]})
                    }
                    var vectorSegmentCache = {};
                    for (var i=0;i<gameData["enemies"].length;i++){
                        var enemyData = gameData["enemies"][i];
                        var enemyDiv = loadEnemy(enemyData["type"]).clone();
                        enemyDiv.data("ticks",enemyData["ticksAlive"])
                                .data("health",enemyData["healthRemaining"])
                                .data("currentX",enemyData["position"]["x"])
                                .data("currentY",enemyData["position"]["y"])
                                .data("effects",enemyData["effects"])
                                .data("magnitudeRemaining",enemyData["magnitudeRemaining"]);
                        
                        var currentVector = vectorSegmentCache[enemyData["currentVector"]];
                        if (!vectorSegmentCache[enemyData["currentVector"]]){
                            currentVector  = vectorPathRoot.findSegmentOfID(enemyData["currentVector"]);
                            vectorSegmentCache[enemyData["currentVector"]] = currentVector;
                        }
                        enemyDiv.data("currentVector",currentVector);
                        $("#gameSpace").append(enemyDiv);
                        enemyDiv.css({top:enemyData["position"]["y"], left:enemyData["position"]["x"]});
                    }
                    
                    //animate tray in
                    $("#controlTray").show('slide',{direction:'right'},1000);
                    console.log(gameData["timeUntilNextWave"]);
                    if (typeof gameData["timeUntilNextWave"] === 'undefined'){
                        timeUntilWave = gameData["timeUntilWave"];
                        runTick = false;
                        stopWaveTimer = false;
                        clockTime = 0;
                        clockTick();
                        startWaveCounter();
                    }else{
                        console.log("Not wave start")
                        $("#waveControls").velocity("slideUp",100);
                        prepareWave();
                        stopWaveTimer = false;
                        timeUntilWave = 30;
                        runTick = true;
                        clockMultiplier = 1;
                        for (var i =0;i<=clockTime;i++){
                            delete enemyQueue[i];
                        }
                        clockTick();
                    }
                    
                }
                
                
                return{
                    /**
                     * Starts the game clock
                     * @author Ignacy Debicki
                     */
                    clockTick: function(){
                        if (clockTickRunning==false){
                            clockTick();
                        }else{
                            //invalidate game as attempted to break it. Do not send high score, do not save.
                            valid=false;
                            console.error("Stop trying!");
                            flashWarning("Stop trying to cheat!");
                        }   
                    },
                    /**
                     * Test function. Wins but game is not valid
                     * @author Ignacy Debicki
                     * @param {number} score Score to pass
                     */
                    win:function(score){
                        stopWaveTimer=true;
                        stopTickFunction=true;
                        loadElement("gameComponents/endGameScreen.html","endGameScreen",function(){
                                        window.endGameScreen.initialise(score,mapID,{"enemiesKilled":1,"towersBuilt":2,"towersUpgraded":3,"projectilesFired":4},false);
                                    });
                    },
                    /**
                     * Loads a map into the game area
                     * @author Ignacy Debicki
                     * @param {object}  mapInfo          Description of map
                     * @param {boolean} startImmediately If to start the game immediately after loading map
                     */
                    setMap:function(mapInfo,startImmediately){
                        mapInfo["mapData"]["id"]=parseInt(mapInfo["id"]);
                        loadMap(mapInfo["mapData"],startImmediately);
                    },
                    /**
                     * Exits the current game
                     * @author Ignacy Debicki
                     */
                    exitGame: function(){
                        exitGame();
                    },
                    /**
                     * Shows the end game screen
                     * @author Ignacy Debicki
                     * @param {number} endScore The final score
                     */
                    showEndGameScreen: function(endScore){
                        if (!endScore){endScore=score;}
                        showEndGameScreen(endScore);
                    },
                    /**
                     * The mapID of the map curently being played
                     * @author Ignacy Debicki
                     * @returns {number} Id of map
                     */
                    mapID: function(){
                        return mapID;
                    },
                    /**
                     * Exports a game to an object which can be saved
                     * @author Ignacy Debicki
                     * @returns {object} A game save object
                     */
                    exportGame:function(){
                        var exportMap = {};
                        if (clockTime==0 && runTick == false){
                            //currently counting down
                            exportMap["timeUntilWave"] = timeUntilWave;
                        }
                        
                        $(".isDragging").each(function(i,e){
                            //refund resources
                            setResources(resources+$(this).data("price"));
                            //remove handlers
                            $('#gameSpace').unbind("");
                            //remove tower
                            $(this).remove();
                        });
                        
                        exportMap["map"] = mapID;
                        exportMap["difficulty"] = "normal";
                        exportMap["baseHealth"] = baseHealth;
                        exportMap["currentScore"] = score;
                        exportMap["currentResources"] = resources;
                        exportMap["wave"] = waveNo;
                        exportMap["towers"]  = [];
                        exportMap["tick"] = clockTime;
                        exportMap["statistics"] = statistics;
                        $(".towerContainer").each(function(n,e){
                            var towerObject = {};
                            towerObject["type"] = $(this).data("towerClass");
                            towerObject["upgradeLevel"] = $(this).data("upgradeLevel");
                            towerObject["reloadState"] = $(this).data("reloadState");
                            towerObject["position"] = {"x":$(this).position().left, "y":$(this).position().top};
                            towerObject["effects"] = [];
                            towerObject["totalPrice"] = $(this).data("totalPrice");
                            exportMap["towers"].push(towerObject);
                        });
                        exportMap["enemies"]=[];
                        $(".enemy").each(function(i,e){
                            var enemyObject = {};
                            var classList = $(this).attr('class').split(/\s+/);
                            $.each(classList, function(index, item) {
                                if (item !== 'enemy') {
                                    enemyObject["type"]=item;
                                    return false;
                                }
                            });
                            enemyObject["ticksAlive"] = $(this).data("ticks");
                            enemyObject["healthRemaining"]  = $(this).data("health");
                            enemyObject["position"] = {"x":$(this).data("currentX"),"y":$(this).data("currentY")};
                            enemyObject["effects"] = [];
                            enemyObject["magnitudeRemaining"] = $(this).data("magnitudeRemaining");
                            enemyObject["currentVector"]  = $(this).data("currentVector").getId();
                            exportMap["enemies"].push(enemyObject);
                        });
                        console.log(exportMap);
                        return exportMap;
                    },
                    /**
                     * Loads a game from a save object
                     * @author Ignacy Debicki
                     * @param {object} gameData Save object
                     */
                    loadGame: function(gameData){
                        loadGame(gameData);
                    }
                }
            })();
            
            
        </script>
    </head>
    <body>
        <div id="controlTray">
            <div id="timeControls">
                <img class="timeControl" id="pause" data-speed="0" src="gameComponents/images/pause.png">
                <img class="timeControl" id="play0.5X" data-speed="0.5" src="gameComponents/images/halfPlay.png">
                <img class="timeControl selectedTimeControl" id="play1X" data-speed="1" src="gameComponents/images/play.png">
                <img class="timeControl" id="play2X" data-speed="2" src="gameComponents/images/ff2x.png">
                <img class="timeControl" id="play3X" data-speed="4" src="gameComponents/images/ff3x.png">
            </div> 
            <div class="sideBarDiv" id="waveControls">
                <img id="timeRemianingImage" src="gameComponents/images/timeRemaining.png">
                <span id="timeRemaining">30</span>
                <button id="startWave">Start wave</button>
            </div>
            <div class="sideBarDiv" id="healthStats">
                <img class="sideBarImage" id="healthImage" src="gameComponents/images/health.png">
                <span class="sideBarStatText" id="healthValue">100</span>
                <img class="sideBarImage" id="resourcesImage" src="gameComponents/images/resources.png">
                <span class="sideBarStatText" id="resourceValue">200</span>
                <div id="healthBar"></div>
            </div>
            <div class="sideBarDiv" id="warning">
                <span id="warningText"></span>
            </div>
            <div class="sideBarDiv" id="sideBarTowerControl">
                <span class="sideBarDivTitle">Tower info</span>
                <img id="activeTowerImage">
                <ul class='activeTowerInfo'>
                    <li>
                        <img class='sideBarActiveTowerStatImage' src='gameComponents/images/attack.png'>
                        <span class='sideBarActiveTowerStatText' id="activeTowerAttack">10</span>
                        <span class='sideBarActiveTowerStatText statModifier' id="statModifierAtttack">+3</span>
                    </li>
                    <li>
                        <img class='sideBarActiveTowerStatImage' src='gameComponents/images/range.png'>
                        <span class='sideBarActiveTowerStatText' id="activeTowerRange">10</span>
                        <span class='sideBarActiveTowerStatText statModifier' id="statModifierRange">+3</span>
                    </li>
                    <li>
                        <img class='sideBarActiveTowerStatImage' src='gameComponents/images/reload.png'>
                        <span class='sideBarActiveTowerStatText' id="activeTowerReloadSpeed">4</span>
                        <span class='sideBarActiveTowerStatText statModifier' id="statModifierReloadSpeed">+3</span>
                    </li>
                    <li>
                        <img class='sideBarActiveTowerStatImage' src='gameComponents/images/resources.png'>
                        <span class='sideBarActiveTowerStatText' id="activeTowerCost">10</span>
                        <span class='sideBarActiveTowerStatText statModifier' id="statModifierCost">+3</span>
                    </li>
                </ul>
                <ul class='upgradeTowerInfo'>
                    <li>
                        <img class='sideBarActiveTowerStatImage' src='gameComponents/images/attack.png'>
                        <span class='sideBarActiveTowerStatText' id="upgradeTowerAttack">+3</span>
                    </li>
                    <li>
                        <img class='sideBarActiveTowerStatImage' src='gameComponents/images/range.png'>
                        <span class='sideBarActiveTowerStatText' id="upgradeTowerRange">+3</span>
                    </li>
                    <li>
                        <img class='sideBarActiveTowerStatImage' src='gameComponents/images/reload.png'>
                        <span class='sideBarActiveTowerStatText' id="upgradeTowerReloadSpeed">+2</span>
                    </li>
                    
                </ul>
                <div id="activeTowerButtons">
                    <button class="sideBarTowerButton" id="sellTower">Sell</button>
                    <button class="sideBarTowerButton" id="upgradeTower">Upgrade</button>
                    <span class='upgradeTowerInfo'>
                        <img class="sideBarUpgradeTowerStatImage" src='gameComponents/images/resources.png'>
                        <span id="upgradeTowerCost">60</span>
                    </span>
                </div>
                
            </div>
            <div class="sideBarDiv" id="sideBarTowerSlots">
                <span class="sideBarDivTitle">Buy towers</span>
            </div>
        </div>
        <div id="gameSpace">
        </div>
    </body>
</html>