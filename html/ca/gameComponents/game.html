<html>
    <head>
        <link rel="stylesheet" type="text/css" href="gameComponents/game.css">
        <!--<script src='jcollision/jquery-collision.min.js'></script>-->
        <script>
            
            window.game=(function(){
                Object.size = function(obj) {
                    var size = 0, key;
                    for (key in obj) {
                        if (obj.hasOwnProperty(key)) size++;
                    }
                    return size;
                };
                
                function VectorPathSegment(x,y,magnitude,links){
                    this.x=null;
                    this.y=null;
                    this.m=null;
                    this.links=[];
                    if (typeof(x)!=="undefined"){
                        this.x=x;
                    }
                    if (typeof(y)!=="undefined"){
                        this.y=y;
                    }
                    if (typeof(magnitude)!=="undefined"){
                        this.m=m;
                    }
                    if (typeof(links)!=="undefined"){
                        this.links=links;
                    }
                    
                }
                    
                VectorPathSegment.prototype = {
                    next: function(){
                        if (this.links.length==1){
                            return this.links[0].segment;
                        }else if(this.links.length==0){
                            return null;
                        }else{
                            //more than one
                            var p = this.links[0].p;
                            var rand = Math.random();
                            var link = 0;
                            while (rand>p){
                                link++;
                                p+=this.links[link].p;
                            }
                            return this.links[link].segment;
                        }
                    },
                    addLink: function(segment,probability){
                        this.links.push({'segment':segment,'p':probability});
                    }
                };

                function simpleSqCollision(e1, e2) {
                      var x1 = e1.offset().left;
                      var y1 = e1.offset().top;
                      var h1 = e1.outerHeight(true);
                      var w1 = e1.outerWidth(true);
                      var b1 = y1 + h1;
                      var r1 = x1 + w1;
                      var x2 = e2.offset().left;
                      var y2 = e2.offset().top;
                      var h2 = e2.outerHeight(true);
                      var w2 = e2.outerWidth(true);
                      var b2 = y2 + h2;
                      var r2 = x2 + w2;

                      if (b1 < y2 || y1 > b2 || r1 < x2 || x1 > r2) return false;
                      return true;
                }

                function extractCornerPoints(element){

                    var points = [];
                    var matrix = element.css("transform");
                    var alpha =0;
                    if (matrix!=='none'){
                        //calculate angle from affine transform
                        var values = matrix.split('(')[1].split(')')[0].split(',');
                        var a = values[0];
                        var b = values[1];
                        alpha = Math.atan2(b, a);
                    }

                    var w = element.outerWidth(false);
                    var h = element.outerHeight(false);

                    var xOffset=element.offset().left;
                    var yOffset=element.offset().top;

                    points.push({'x':xOffset+Math.sin(alpha)*h,'y':yOffset});
                    points.push({'x':xOffset+w*Math.cos(alpha)+Math.sin(alpha)*h,'y':yOffset+w*Math.sin(alpha)});
                    points.push({'x':(xOffset+w*Math.cos(alpha)),'y':(yOffset+w*Math.sin(alpha))+h*Math.cos(alpha)});
                    points.push({'x':xOffset,'y':yOffset+h*Math.cos(alpha)});

                    return points
                }
                
                function tileCollision(tile,object){
                    
                    if (tile.hasClass("mapPathTile")){
                        var sqPoints = [];
                        var crPoints = [];
                        var objectPoints = [];
                        sqPoints.push({'x':tile.children("#nw.marker").offset().left,
                                   'y':tile.children("#nw.marker").offset().top});
                        sqPoints.push({'x':tile.children("#ne.marker").offset().left,
                                       'y':tile.children("#ne.marker").offset().top});
                        sqPoints.push({'x':tile.children("#se.marker").offset().left,
                                       'y':tile.children("#se.marker").offset().top});
                        sqPoints.push({'x':tile.children("#sw.marker").offset().left,
                                       'y':tile.children("#sw.marker").offset().top});

                        crPoints.push({'x':tile.children("#cw.marker").offset().left,
                                       'y':tile.children("#cw.marker").offset().top,
                                       'r':pathRadius});
                        crPoints.push({'x':tile.children("#ce.marker").offset().left,
                                       'y':tile.children("#ce.marker").offset().top,
                                       'r':pathRadius});

                        objectPoints.push({'x':object.offset().left,
                                           'y':object.offset().top});
                        objectPoints.push({'x':object.offset().left + object.outerWidth(),
                                           'y':object.offset().top});
                        objectPoints.push({'x':object.offset().left + object.outerWidth(),
                                           'y':object.offset().top + object.outerHeight()});
                        objectPoints.push({'x':object.offset().left,
                                           'y':object.offset().top + object.outerHeight()});
                    
                    return (advancedSqCollision(sqPoints,objectPoints) || circleSqCollision(crPoints[0],objectPoints) || circleSqCollision(crPoints[1],objectPoints));
                        
                    }else{
                        return simpleSqCollision(tile,object);
                    }
                    
                    
                }
                
                function circleSqCollision(circle,square){
                    
                    for (var i = 0; i<3;i++){
                        var A = square[i];
                        var B = square[i+1];
                        if (crLineCollision(circle,[A,B])==true){
                            return true
                        }
                    }
                    return false
                }
                
                function crLineCollision(circle,linePoints){
                    
                    if (Math.sqrt(Math.pow(linePoints[0].x-circle.x,2)+Math.pow(linePoints[0].y-circle.y,2))<circle.r ||
                        Math.sqrt(Math.pow(linePoints[1].x-circle.x,2)+Math.pow(linePoints[1].y-circle.y,2))<circle.r
                       ){
                        return true;
                    }
                    
                    var directionVector = {'x':(linePoints[0].x - linePoints[1].x),'y':(linePoints[0].y - linePoints[1].y)};
                    var magnitudeLimit = Math.sqrt(Math.pow(directionVector.x,2)+Math.pow(directionVector.y,2));
                    //obtain unit vector
                    directionVector.x/=magnitudeLimit;
                    directionVector.y/=magnitudeLimit;
                    var a = Math.pow(directionVector.x,2)+Math.pow(directionVector.y,2);
                    var b = 2*(directionVector.x*linePoints[0].x+directionVector.y*linePoints[0].y-circle.x*directionVector.x-circle.y*directionVector.y)
                    var c = Math.pow(circle.x,2)+ Math.pow(circle.y,2)+ Math.pow(linePoints[0].x,2)+ Math.pow(linePoints[0].y,2)- 2*(linePoints[0].x*circle.x+linePoints[0].y*circle.y)-Math.pow(circle.r,2);
                    
                    var determinant = Math.pow(b,2)-4*a*c;
                    if (determinant==0){
                        var lambda = Math.pow(b,2)/(2*a);
                        if (lambda<=magnitudeLimit && lambda >= 0){
                            return true;
                        }
                    }else if(determinant>0){
                        var lambda = [(Math.pow(b,2)-Math.sqrt(determinant))/(2*a),
                                      (Math.pow(b,2)+Math.sqrt(determinant))/(2*a)];
                        for (var i = 0;i<2;i++){
                            var l = lambda[i];
                            if (l<=magnitudeLimit && l >= 0){
                                return true;
                            }
                        }   
                    }
                    return false;
                }
                            
                function advancedSqCollision (a, b) {

                    /*var a = extractCornerPoints(e1);
                    var b = extractCornerPoints(e2);*/
                    var polygons = [a, b];
                    var minA, maxA, projected, i, i1, j, minB, maxB;

                    for (i = 0; i < polygons.length; i++) {

                        // for each polygon, look at each edge of the polygon, and determine if it separates
                        // the two shapes
                        var polygon = polygons[i];
                        for (i1 = 0; i1 < polygon.length; i1++) {

                            // grab 2 vertices to create an edge
                            var i2 = (i1 + 1) % polygon.length;
                            var p1 = polygon[i1];
                            var p2 = polygon[i2];

                            // find the line perpendicular to this edge
                            var normal = { x: p2.y - p1.y, y: p1.x - p2.x };

                            minA = maxA = undefined;
                            // for each vertex in the first shape, project it onto the line perpendicular to the edge
                            // and keep track of the min and max of these values
                            for (j = 0; j < a.length; j++) {
                                projected = normal.x * a[j].x + normal.y * a[j].y;
                                if (minA===undefined || projected < minA) {
                                    minA = projected;
                                }
                                if (maxA===undefined || projected > maxA) {
                                    maxA = projected;
                                }
                            }

                            // for each vertex in the second shape, project it onto the line perpendicular to the edge
                            // and keep track of the min and max of these values
                            minB = maxB = undefined;
                            for (j = 0; j < b.length; j++) {
                                projected = normal.x * b[j].x + normal.y * b[j].y;
                                if (minB===undefined || projected < minB) {
                                    minB = projected;
                                }
                                if (maxB===undefined || projected > maxB) {
                                    maxB = projected;
                                }
                            }

                            // if there is no overlap between the projects, the edge we are looking at separates the two
                            // polygons, and we know there is no overlap
                            if (maxA < minB || maxB < minA) {
                                return false;
                            }
                        }
                    }
                    return true;
                };

                function crCollision(circle, rect) {
                    var cr = circle.outerWidth(true)/2;
                    var cx = circle.offset().left+cr;
                    var cy = circle.offset().top+cr;

                    var rx = rect.offset().left;
                    var ry = rect.offset().top;
                    var rh = rect.outerHeight(true);
                    var rw = rect.outerWidth(true);
                    var distX = Math.abs(cx - rx - rw / 2);
                    var distY = Math.abs(cy - ry - rh / 2);

                    if (distX > (rw / 2 + cr)) {
                        return false;
                    }
                    if (distY > (rh / 2 + cr)) {
                        return false;
                    }

                    if (distX <= (rw / 2)) {
                        return true;
                    }
                    if (distY <= (rh / 2)) {
                        return true;
                    }

                    var dx = distX - rw / 2;
                    var dy = distY - rh / 2;
                    return (dx * dx + dy * dy <= (cr * cr));
                }

                function rankByDistance(enemies){
                    var distanceArray = [];
                    var enemyArray = [];
                    for (i=0;i<enemies.length;i++){
                        var enemy = enemies[i];
                        var distanceTravelled = $(enemy).data("ticks")*$(enemy).data("speed");
                        if (distanceArray.length>0){
                            for (j=0;j<distanceArray.length;j++){
                                if (distanceArray[j]<distanceTravelled){
                                    distanceArray.splice(j,0,distanceTravelled);
                                    enemyArray.splice(j,0,enemy);
                                    break;
                                }else if (j==distanceArray.length-1){
                                    distanceArray.push(distanceTravelled);
                                    enemyArray.push(enemy);
                                    break;
                                }
                            }
                        }else{
                            distanceArray.push(distanceTravelled);
                            enemyArray.push(enemy);
                        }

                    }
                    return enemyArray;
                }

                //init global vars
                var baseClock = 300;
                var clockMultiplier = 1;
                var prevClockMultiplier = 1;
                var clockTime = 0;
                //set constants
                var gameHeight = 675;
                var gameWidth = 875;
                var baseHealth = 100;
                var score = 0;
                var mapPath = [];
                var vectorPath = [];
                var vectorPathRoot = null;
                var pathRadius = 0;
                var towers = [];
                var stopTickFunction = false;
                var enemyQueue = {};
                var enemyDB = {};
                var towerDB = {};
                var projectileDB = {};
                var currentDrag = null;
                var mousePos = { x: 0, y: 0 };
                var maxHealth = 100;
                var resources = 0;
                var waves = [];
                var waveNo = 0;
                var events = {};
                var timeUntilWave = 30;
                var stopWaveTimer = false
                var runTick = false;
                var pauseWaveTimer = false;
                var clockTickRunning=true;
                var valid = true;
                var warningMessageTimeout=null;
                var animationArray = [];
                var mapID = null;
                
                
                
                $("document").ready(function(){
                    //set self to hidden
                    $("#controlTray").hide('fade',0,function(){
                        $("#controlTray").removeAttr("display");
                    });
                    $("#sideBarTowerControl").css("display","block");
                    $("#sideBarTowerControl").velocity("slideUp",0);
                    hideUpgradeStats();
                    hideWarning();

                    //set handlers
                    $(".timeControl").click(changePlaybackTime);
                    $("#healthBar").progressbar({
                        disabled: false,
                        max: maxHealth,
                        value: baseHealth
                    })
                    $("#sellTower").click(sellTower);
                    $("#upgradeTower").click(upgradeTower);
                    $("#upgradeTower").hover(showUpgradeStats,hideUpgradeStats);
                    $("#startWave").click(function(){stopWaveTimer=true;});

                    $(document).mousemove(function(event) {
                        mousePos.x = event.pageX;
                        mousePos.y = event.pageY;
                    });
                    $("#gameSpace").mousedown(removeTowerSelection);


                });


                $(document).keyup(function(e) {
                    if (e.keyCode == 27) { 
                        // escape key pressed - if moving any tower, stop moving and refund
                        $(".isDragging").each(function(i,e){
                            //refund resources
                            setResources(resources+$(this).data("price"));
                            //remove handlers
                            $('#gameSpace').unbind("");
                            //remove tower
                            $(this).remove();
                        });
                    }
                });
                
                function start(){
                    console.log("starting");
                    //set wave number to 0
                    waveNo = 0;
                    //set wave timer
                    timeUntilWave = 30;

                    //animate tray in
                    $("#controlTray").show('slide',{direction:'right'},1000);

                    //display wave count down
                    startWaveCounter();
                    //start ticks
                    runTick=false;
                    clockTick();
                }
                
                function startWaveCounter(){
                    prepareWave();
                    $("#waveControls").velocity("slideDown",100);
                    waveCountDown();
                }

                function waveCountDown(){
                    $("#timeRemaining").html(timeUntilWave);
                    //decrement time if pause menu is not loaded
                    if ($("#pauseMenu").length == 0){
                        timeUntilWave--;
                    }


                    if (timeUntilWave>=0 && !stopWaveTimer){
                        setTimeout(waveCountDown,1000);
                    }else{
                        //reset
                        stopWaveTimer = false;
                        timeUntilWave = 30;

                        //time expired start wave
                        startWave(waveNo);
                        //hide countdown
                        $("#waveControls").velocity("slideUp",100);
                    }
                }

                function executeEvent(event,arg){
                    console.log(event,arg);
                    switch(event){
                        case "ENABLE":
                            //is array of towers
                            for (var tower in arg){
                                if (arg.hasOwnProperty(tower)){
                                    //put tower into sideBar
                                    loadSideBarTower(arg[tower]);
                                }
                            }
                            break;
                        default:
                            console.log("invalid event");
                    }
                }

                function loadMap(map){
                    setBaseHealth(map["maxBaseHealth"]);
                    changeHealth(map["startingBaseHealth"]);
                    setResources(map["startingResources"]);
                    mapID = map["id"];
                    //draw the map so objects can interact with it
                    drawMap(map);
                    //calculate path for enemies
                    vectorPathRoot = calculateVectorPaths(mapPath).root;
                    console.log(vectorPathRoot);
                    //set waves
                    waves = map["waves"];
                    //make sure all correct enemies are loaded
                    prepareWaves();
                    //set events
                    events = map["events"];
                    //make sure all correct towers are loaded in
                    prepareEvents();
                    //execute any events to be executed before start of clock   
                    if (events["pre"]){
                        var preEvents = events["pre"];
                        for (var event in preEvents){
                            if (events["pre"].hasOwnProperty(event)){
                                executeEvent(event,preEvents[event]);
                            }
                        }
                    }
                    start();
                }

                function calculateVectorPaths(points){
                    var root = null;
                    var lastSegments = [];
                    for (var i=0;i<points.length-1;i++){
                        var currentSegment = new VectorPathSegment();
                        var p1 = points[i].slice();
                        var p2 = points[i+1].slice();
                        if (typeof(p1[0])=="number"){
                            if (typeof(p2[0])!=="number"){
                                p2 = p2[0].start;
                            }
                            var vector = calculateVector(p1,p2);
                            currentSegment.x=vector.x;
                            currentSegment.y=vector.y;
                            currentSegment.m=vector.m;
                            if (lastSegments.length==0){
                                root=currentSegment;
                            }else{
                                extendPath(lastSegments,currentSegment,1);
                            }
                        lastSegments=[currentSegment];
                        }else{
                            //handle split
                            var start  = p1[0].start.slice();
                            var endingSegments = [];
                            for (var j = 1;j<p1.length;j++){
                                var pathProbability = p1[0]['p'+j];
                                var pointArray = [start.slice()];
                                pointArray = pointArray.concat(p1[j].slice());
                                pointArray.push(p2.slice());
                                var pathSegments = calculateVectorPaths(pointArray.slice());
                                extendPath(lastSegments,pathSegments.root,pathProbability);
                                endingSegments = endingSegments.concat(pathSegments.last.slice());
                            }
                            lastSegments=endingSegments.slice();
                        }
                    }
                    return {'root':root,'last':lastSegments};
                }
                
                function extendPath(lastSegments,root,prob){
                    for (var i = 0;i<lastSegments.length;i++){
                        var s = lastSegments[i];
                        s.addLink(root,prob);
                    }
                }
                
                function calculateVector(p1,p2){
                    var directionVector = {'x':(p2[0] - p1[0]),'y':(p2[1] - p1[1])};
                    directionVector.m = Math.sqrt(Math.pow(directionVector.x,2)+Math.pow(directionVector.y,2));
                    //obtain unit vector
                    directionVector.x/=directionVector.m;
                    directionVector.y/=directionVector.m;
                    return directionVector;
                }

                function drawMap(data){
                    pathRadius = data["radius"];
                    mapPath = data["path"];
                    var gameContainer = $("#gameSpace");
                    //draw map path using divs
                    parsePath(mapPath.slice(),pathRadius)
                    //position base
                    var baseDiv = $('<div class="baseTile tile">');
                    gameContainer.append(baseDiv);
                    baseDiv.css({left: data["baseLocation"][0] - 35, top: data["baseLocation"][1] - 35, width: data["baseRadius"]*2,height: data["baseRadius"]*2});
                }
                
                function parsePath(path,pathRadius){
                    var pathComponentHeight = pathRadius * 2;
                    for ( i=0;i<path.length-1;i++){
                        if (typeof(path[i][0])!=="number"){
                            //split
                            var currentArray = path[i];
                            var startPoint = currentArray[0]["start"];
                            var endPoint = [];
                            if (typeof(path[i+1][0])!=="number"){
                                endPoint = [path[i+1][0]["start"][0],path[i+1][0]["start"][1]];
                            }else{
                                endPoint = [path[i+1][0],path[i+1][1]];
                            }
                            
                            for (j=1;j<currentArray.length;j++){
                                var pathArray = currentArray[j].slice();
                                pathArray.unshift(startPoint);
                                pathArray.push(endPoint);
                                parsePath(pathArray.slice(),pathRadius);
                            }
                        }else{
                            var point = {"x":path[i][0],"y":path[i][1]};
                            var nextPoint = {};
                            if (typeof(path[i+1][0])!=="number"){
                                nextPoint = {"x":path[i+1][0]["start"][0],"y":path[i+1][0]["start"][1]}
                            }else{
                                nextPoint = {"x":path[i+1][0],"y":path[i+1][1]};
                            }
                            parseElement(point,nextPoint,pathComponentHeight,pathRadius);
                        }
                    }
                }
                function parseElement(point,nextPoint,pathComponentHeight,pathRadius){
                    
                    //always take smaller value of x and y
                    var pos = {};
                    var pointOrder = {'from':null,'to':null};
                    var horizontal={"x":1,"y":0};
                    if (point.x==nextPoint.x){
                        var minY = Math.min(point.y,nextPoint.y);
                        if (minY==point.y){
                            pointOrder.from=point;
                            pointOrder.to=nextPoint
                        }else{
                            pointOrder.from=nextPoint;
                            pointOrder.to=point;
                        }
                    }else{
                        var minX = Math.min(point.x,nextPoint.x);
                        if (minX==point.x){
                            pointOrder.from=point;
                            pointOrder.to=nextPoint
                        }else{
                            pointOrder.from=nextPoint;
                            pointOrder.to=point;
                        }
                    }
                    //work out angle between the two points
                    var angleFromHorizontal = Math.atan((pointOrder.to.y-pointOrder.from.y)/(pointOrder.to.x-pointOrder.from.x));
                    pos["x"] = pointOrder.from.x- pathRadius * Math.cos(angleFromHorizontal);
                    pos["y"] = pointOrder.from.y-pathRadius - pathRadius * Math.sin(angleFromHorizontal);
                    //use pythagoras to calculate length of div
                    var pathComponentWidth = magnitude({'x':pointOrder.to.x-pointOrder.from.x+2*pathRadius*Math.cos(angleFromHorizontal),'y':pointOrder.to.y-pointOrder.from.y+2*pathRadius*Math.sin(angleFromHorizontal)});

                    //add to layout
                    createPathElement({"width":pathComponentWidth,"height":pathComponentHeight},pos,angleFromHorizontal,pathRadius);
                }
                
                
                function magnitude(vector){
                    return Math.pow(Math.pow(vector.x,2)+Math.pow(vector.y,2),0.5);
                }
                
                function createPathElement(size,pos,angle,pathRadius){
                    var gameContainer = $("#gameSpace")
                    var pathComponent = $(`
                        <div id="`+i+`" class="mapPathTile tile">
                            <div class="marker" id = "nw" style="left:`+pathRadius+`; top:0;"></div>
                            <div class="marker" id = "ne" style="right:`+pathRadius+`; top:0;"></div>
                            <div class="marker" id = "se" style="right:`+pathRadius+`; bottom:0;"></div>
                            <div class="marker" id = "sw" style="left:`+pathRadius+`; bottom:0;"></div>
                            <div class="marker" id = "cw" style="left:`+pathRadius+`; top:`+pathRadius+`;"></div>
                            <div class="marker" id = "ce" style="right:`+pathRadius+`; top:`+pathRadius+`;"></div>
                        </div>`);
                    gameContainer.append(pathComponent);
                    pathComponent.css({left: pos.x,
                                        top: pos.y,
                                        width:size.width,
                                        height: size.height,
                                        transform:"rotate("+angle+"rad)",
                                        borderRadius: pathRadius});
                }

                function prepareEvents(){
                    for (var event in events) {
                        if (events.hasOwnProperty(event)){
                            for (var key in event) {
                                if (event.hasOwnProperty(key) && key =="ENABLE"){
                                    for (tower in key){
                                        if (key.hasOwnProperty(tower)){
                                            loadTower(key[tower]);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                function prepareWaves(){
                    for (var waveKey in waves){
                        //make sure enemies are loaded for the wave
                        var wave = waves[waveKey];
                        if (waves.hasOwnProperty(waveKey)) { 
                            for (var tickKey in wave) {
                                if (wave.hasOwnProperty(tickKey)) { 
                                    var tick = wave[tickKey];
                                    for (var key in tick){
                                        if (tick.hasOwnProperty(key) && key != "delay") { 
                                            loadEnemy(key);
                                        }
                                    }
                                }
                            }
                        }
                    }

                }

                function prepareWave(){
                    //queue all enemy for wave
                    enemyQueue = {};
                    var delay = 1;
                    var wave = waves[waveNo];
                    for (var tickKey in wave) {
                        if (wave.hasOwnProperty(tickKey)) { 
                            var tick = wave[tickKey];
                            delay = parseInt(tick["delay"]);
                            for (var key in tick){
                                if (tick.hasOwnProperty(key) && key != "delay") { 
                                    for (var i = 0;i<tick[key];i++){
                                        var tickTrigger = parseInt(tickKey) + delay * i
                                        if (tickTrigger in enemyQueue){
                                            enemyQueue[tickTrigger].push(loadEnemy(key));
                                        }else{
                                            enemyQueue[tickTrigger]=[loadEnemy(key)];
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                function startWave(waveNo){
                    //start tick
                    clockTime=0;
                    runTick=true;
                }
                function upgradeTower(){
                    $(".isSelected").each(function(i,e){
                        if ($(this).data("upgradeLevel")<2){
                            if(buyUpgrade()==true){
                                var currentSelection = $(".isSelected")[0];
                                var towerLevel = $(currentSelection).data("upgradeLevel");
                                var towerClass = $(currentSelection).data("towerClass");
                                var upgradeTowerData = towerDB[towerClass][towerLevel+1];
                                var currentRange = $(currentSelection).data("range");
                                var newRange = upgradeTowerData["range"];
                                var pos = {"x":$(currentSelection).css("left"),"y":$(currentSelection).css("top")};
                                if (currentRange!=newRange){
                                    var rangeDiff = newRange - currentRange;
                                    pos.x+=rangeDiff;
                                    pos.y+=rangeDiff;
                                }

                                var upgradeTowerDiv = upgradeTowerData["divBase"].clone();
                                $(upgradeTowerDiv).data("totalPrice", $(currentSelection).data("price") + $(upgradeTowerDiv).data("price"));
                                upgradeTowerDiv.css("top",pos.y)
                                                .css("left",pos.x);
                                $(currentSelection).remove();

                                $("#gameSpace").append(upgradeTowerDiv);
                                $(upgradeTowerDiv).children(".tower").click(selectTower);
                                $(upgradeTowerDiv).children(".tower").addClass("tile");
                                $(upgradeTowerDiv).children(".tower").trigger("click");
                                hideUpgradeStats();
                                if (towerLevel<1){
                                    showUpgradeStats();
                                }
                                
                                //set tower as tile


                            }else{
                                flashWarning("Not enough resources to buy upgrade");
                            }

                        }
                    });
                }

                function buyUpgrade(){
                    var currentSelection = $(".isSelected")[0];
                    var towerLevel = $(currentSelection).data("upgradeLevel");
                    var towerClass = $(currentSelection).data("towerClass");
                    var upgradeTowerData = towerDB[towerClass][towerLevel+1];
                    if (resources-upgradeTowerData["cost"]>=0){
                        setResources(resources-upgradeTowerData["cost"]);
                        return true;
                    }else{
                        return false;
                    }
                }

                function sellTower(){
                    $(".isSelected").each(function(i,e){
                        //return 75% of resources
                        setResources(resources+Math.floor($(this).data("totalPrice")*0.75));
                        //remove
                        $(this).remove();
                    });
                    removeTowerSelection();
                }

                function updateActiveTowerInfo(){
                    $(".isSelected").each(function(i,e){
                        $("#activeTowerImage").attr("src",$(this).children("img").attr("src"));
                        $("#activeTowerAttack").html($(this).data("damage"));
                        $("#activeTowerRange").html($(this).data("range"));
                        $("#activeTowerCost").html(Math.floor($(this).data("totalPrice")*0.75));
                        $("#activeTowerReloadSpeed").html($(this).data("reloadSpeed"));
                        if ($(this).data("upgradeLevel")==2){
                            $("#upgradeTower").hide();
                        }else{
                            $("#upgradeTower").show();
                        }
                    });
                }
            
                function showUpgradeStats(){
                    var currentSelection = $(".isSelected")[0];
                    var towerLevel = $(currentSelection).data("upgradeLevel");
                    var towerClass = $(currentSelection).data("towerClass");
                    var upgradeTowerData = towerDB[towerClass][towerLevel+1];
                    $("#upgradeTowerAttack").html(upgradeTowerData["damage"]);
                    $("#upgradeTowerRange").html(upgradeTowerData["range"]);
                    $("#upgradeTowerReloadSpeed").html(upgradeTowerData["reloadSpeed"]);
                    $("#upgradeTowerCost").html(upgradeTowerData["cost"]);
                    $(".upgradeTowerInfo").css("display","inline-block");
                }
            
                function hideUpgradeStats(){
                    $(".upgradeTowerInfo").css("display","none");
                }

                function removeTowerSelection(){
                    $(".isSelected").removeClass("isSelected");
                    $("#sideBarTowerControl").velocity("slideUp",100);
                }

                function setBaseHealth(newHealth){
                    maxHealth=newHealth;
                    $("#healthBar").progressbar( "option", "max", maxHealth );
                }

                function changeHealth(health){
                    baseHealth=health;
                    $("#healthValue").html(baseHealth);
                    $("#healthBar").progressbar("value",baseHealth);
                    if (baseHealth<=0){
                        stopTickFunction=true;
                        alert("your base has been destroyed");
                        //show high score page
                        exitGame();
                    }
                }

                function setResources(newResources){
                    resources=newResources;
                    $("#resourceValue").html(resources);
                }



                function saveScore(){
                    
                }

                function exitGame(){
                    timeUntilWave=30;
                    runTick=false;
                    stopTickFunction=true;
                    stopWaveTimer=true;
                    $("#controlTray").show('slide',{direction:'right'},500,function(){
                        removeElement("mainGame");
                        showStartScreen();
                    });
                    window.game=null;
                }
                function calculatePath(x,y,currentVector,movementRemaining,magnitudeRemaining){
                    if (movementRemaining<=magnitudeRemaining){
                        x += currentVector.x*movementRemaining;
                        y += currentVector.y*movementRemaining;
                        magnitudeRemaining -=movementRemaining;
                    }else{
                        //reach end of path
                        x += currentVector.x*magnitudeRemaining;
                        y += currentVector.y*magnitudeRemaining;
                        
                        var nextVector = currentVector.next();
                        console.log(currentVector,nextVector);
                        if(nextVector==null){
                            //return as at end anyway
                            magnitudeRemaining=0;
                        }else{
                            //more vector paths to calculate
                            //recalculate movementRemaining
                            movementRemaining -= magnitudeRemaining;
                            //recalculate magnitudeRemaining
                            magnitudeRemaining = nextVector.m;
                            return calculatePath(x,y,nextVector,movementRemaining,magnitudeRemaining);
                        }
                    }
                    return {
                        "x":x,
                        "y":y,
                        "vector":currentVector,
                        "magnitudeRemaining":magnitudeRemaining
                    };
                }
                function moveEnemies(){
                    $("#gameSpace .enemy").each(function(i,e){

                        //check collision with final base
                        if ($(this).data("currentVector").next()==null){
                            if (simpleSqCollision($(this),$(".baseTile"))){
                                dealBaseDamage($(this).data("damage"));
                                $(this).remove(); 
                                return;
                            }   
                        }
                        var returnData = calculatePath($(this).data("currentX"),
                                                        $(this).data("currentY"),
                                                        $(this).data("currentVector"),
                                                        $(this).data("speed"),
                                                        $(this).data("magnitudeRemaining")
                                                       );

                        $(this).data("currentVector",returnData.vector);
                        $(this).data("magnitudeRemaining",returnData.magnitudeRemaining);
                        $(this).data("currentX",returnData.x);
                        $(this).data("currentY",returnData.y);

                        $(this).velocity({
                            left:returnData.x,
                            top: returnData.y,
                        },baseClock/clockMultiplier,"linear",{queue:false});
                        //increase no. of ticks survived
                        var ticks = $(this).data("ticks");
                        $(this).data("ticks", ticks+1);


                    });
                }
                
            
                function shootProjectiles(){
                    $("#gameSpace .towerContainer:not(.isDragging)").each(function(i,e){
                        var reloadState = $(this).data("reloadState");
                        reloadState+=1
                        //if reloaded, fire
                        if((reloadState % $(this).data("reloadSpeed")) == 0){
                            var target = findTarget($(this));
                            if (target!==null && target!==undefined && target!==[]){
                                fireTower($(this),$(target));
                            }
                            reloadState=0;
                        }
                        $(this).data("reloadState",reloadState);

                    });
                }

                function clockTick(){
                    clockTickRunning=true;
                    //perform updates
                    if(runTick){
                        //spawn any new enemies in queue
                        spawnEnemy();
                        //check if projectiles collided with an enemy
                        checkProjectileCollisions();
                        //move enemies
                        moveEnemies();
                        //shoot projectiles
                        shootProjectiles();
                        //update the status of selected towers
                        updateActiveTowerInfo();
                        //update tick
                        clockTime++;
                    }
                    //schedual function with correct clock delay
                    if (clockMultiplier>0){
                        if (stopTickFunction==false){
                            //check if end of wave
                            if (endOfWave()&&runTick==true){
                                //increment wave no
                                waveNo++;
                                if (waveNo>=waves.length){
                                    alert("You have won!");
                                    exitGame();
                                    stopTickFunction=true;
                                    runTick=false;
                                }else{
                                    //stop ticks
                                    runTick=false;
                                    clockTime=0;
                                    //start countdown
                                    startWaveCounter();
                                }
                            }
                            setTimeout(clockTick,baseClock/clockMultiplier);
                        }else{
                            stopTickFunction = false;
                        }
                    }else{
                        //display pause menu
                        clockTickRunning=false;
                        loadElement("gameComponents/pauseMenu.html","pauseMenu");
                    }
                }

                function endOfWave(){
                    if (Object.size(enemyQueue)>0){
                        return false;
                    }
                    if ($(".enemy")[0]){
                        return false;
                    }
                    //all enemies from wave killed
                    return true;
                }

                function dealBaseDamage(damage){
                    changeHealth(baseHealth-damage);
                }

                function changePlaybackTime(evt){
                    clockMultiplier = $(this).data("speed");
                    $(".selectedTimeControl").removeClass("selectedTimeControl");
                    $(this).addClass("selectedTimeControl");
                }


                function loadEnemy(enemyName){
                    if ((enemyName in enemyDB)==false){
                        var data = $.ajax({
                            type: "GET",
                            url: "gameComponents/enemies/"+enemyName+".ed",
                            dataType: 'json',
                            async: false,
                            success: function(data) {}
                        })['responseJSON'];
                        var enemyImg = $(`<img src='gameComponents/enemies/`+data["icon"]+`' 
                                            class='enemy ` + enemyName + `' 
                                            style='
                                                position: absolute;
                                                width:`+data["width"]+`px;
                                                height:`+data["height"]+`px;
                                                left:`+(mapPath[0][0]-(data["width"]/2))+`px;
                                                top:`+(mapPath[0][1]-(data["height"]/2))+`px;'
                                            data-health='`+data["health"]+`' 
                                            data-damage='`+data["damage"]+`' 
                                            data-death='`+data["death"]+`' 
                                            data-speed='`+data["speed"]+`' 
                                            data-magnitude-remaining='`+vectorPathRoot.m+`' 
                                            data-current-x='`+(mapPath[0][0]-(data["width"]/2))+`' 
                                            data-current-y='`+(mapPath[0][1]-(data["height"]/2))+`' 
                                            data-resources='`+data["resources"]+`' 
                                            data-ticks='0'>`);
                        data["divBase"]=enemyImg;
                        enemyDB[enemyName]=data;
                        return enemyImg;
                    }else{
                        return enemyDB[enemyName]["divBase"];
                    }

                }

                function spawnEnemy(){
                    if (enemyQueue[clockTime]){
                        for (var enemyDiv in enemyQueue[clockTime]){
                            if (enemyQueue[clockTime].hasOwnProperty(enemyDiv)){
                                var enemy = enemyQueue[clockTime][enemyDiv].clone()
                                enemy.data("currentVector",vectorPathRoot);
                                $("#gameSpace").append(enemy);
                            }
                        }
                        delete enemyQueue[clockTime];
                    }

                }

                function loadSideBarTower(towerName){
                    var towerData = loadTower(towerName);
                    var baseTower = towerData["level"][0]
                    var towerDiv = baseTower["divBase"];
                    var towerSideBarImage = $("<img id='"+towerName+"' class='towerSideBarImage' src='gameComponents/towers/"+ baseTower["icon"] +"' >");
                    towerSideBarImage.data("divBase",towerDiv);
                    towerSideBarImage.data("cost",baseTower['cost']);
                    towerSideBarImage.click(buyTower);
                    var towerDescription = $(`<ul class='towerInfo'>
                                                <li>
                                                    <img class='sideBarStatImage' src='gameComponents/images/attack.png'>
                                                    <span class='sideBarStatText'>`+baseTower["damage"]+`</span>
                                                </li>
                                                <li>
                                                    <img class='sideBarStatImage' src='gameComponents/images/range.png'>
                                                    <span class='sideBarStatText'>`+baseTower["range"]+`</span>
                                                </li>
                                              </ul>
                                              <ul class='towerInfo'>
                                                <li>
                                                    <img class='sideBarStatImage' src='gameComponents/images/reload.png'>
                                                    <span class='sideBarStatText'>`+(10-baseTower['reloadSpeed'])+`</span>
                                                </li>
                                                <li>
                                                    <img class='sideBarStatImage' src='gameComponents/images/resources.png'>
                                                    <span class='sideBarStatText'>`+baseTower['cost']+`</span>
                                                </li>
                                               </ul>`);
                    var towerSideBarDiv = $("<div class='sideBarTowerDiv'>");
                    towerSideBarDiv.append(towerSideBarImage)
                                    .append(towerDescription);

                    $("#sideBarTowerSlots").append(towerSideBarDiv);
                }

                function loadTower(towerName){
                    if ((towerName in towerDB)==false){
                        var data = $.ajax({
                            type: "GET",
                            url: "gameComponents/towers/"+towerName+".td",
                            dataType: 'json',
                            async: false,
                            success: function(data) {}
                        })['responseJSON'];
                        towerDB[towerName]=[];
                        for (i=0;i<data["level"].length;i++){
                            var towerLevelData = data["level"][i];
                            var towerDiv = $(`<div class='`+towerName+i+` towerContainer' style='width:`+(towerLevelData["range"]*2)+`px; height:`+(towerLevelData["range"]*2)+`px;'
                                             data-width='`+data["width"]+`' 
                                             data-height='`+data["height"]+`' 
                                             data-reload-speed='`+towerLevelData["reloadSpeed"]+`' 
                                             data-projectile-fired='`+towerLevelData["projectileName"]+`' 
                                             data-no-projectiles-fired='`+towerLevelData["projectiles"]+`' 
                                             data-damage='`+towerLevelData["damage"]+`' 
                                             data-reload-state='0' 
                                             data-price='`+towerLevelData["cost"]+`' 
                                             data-total-price='`+towerLevelData["cost"]+`'
                                             data-range='`+towerLevelData["range"]+`' 
                                             data-upgrade-level='`+i+`'
                                             data-tower-class='`+towerName+`'>
                                             <div class='targetDisk `+towerName+i+`'></div>
                                             <img class= 'tower `+towerName+i+`'
                                                src='gameComponents/towers/`+towerLevelData["icon"]+`' 
                                                style='width:`+data["width"]+`px; height:`+data["height"]+`px;left:`+(towerLevelData["range"]-data["width"]/2)+`px;top:`+(towerLevelData["range"]-data["height"]/2)+`px;'>
                                            </div>`);
                            towerLevelData["divBase"]=towerDiv;
                            towerDB[towerName][i]=towerLevelData;
                            loadProjectile(towerLevelData["projectileName"]);
                        }
                        return data;
                    }else{
                        return towerDB[towerName][0];
                    }
                }

                function buyTower(evt){
                    if ((resources>=$(this).data("cost")) && !$(".isDragging")[0]){
                        setResources(resources-$(this).data("cost"));
                        spawnTower($(this).data("divBase"));
                    }else{
                        flashWarning("Not enough resources or already bought tower");
                    }
                }

                function spawnTower(tower){
                    //remove selection of any previous tower
                    removeTowerSelection();
                    //spawn in new tower
                    var newTowerDiv = tower.clone();
                    newTowerDiv.addClass("isDragging");
                    $("#gameSpace").append(newTowerDiv);
                    currentDrag=newTowerDiv;
                    //move to current position of mouse
                    finalX = mousePos.x-$("#gameSpace").offset().left-newTowerDiv.outerHeight(false)/2;
                    finalY = mousePos.y-$("#gameSpace").offset().top-newTowerDiv.outerWidth(false)/2;
                    if (finalX<-(newTowerDiv.outerWidth(false)/2 - newTowerDiv.data("width")/2)){
                        finalX=-(newTowerDiv.outerWidth(false)/2 - newTowerDiv.data("width")/2);
                    }else if(finalX> $("#gameSpace").innerWidth()-3-(newTowerDiv.outerWidth(false)/2 + newTowerDiv.data("width")/2)){
                        finalX = $("#gameSpace").innerWidth()-3-(newTowerDiv.outerWidth(false)/2 + newTowerDiv.data("width")/2);
                    }
                    if (finalY<-(currentDrag.outerWidth(false)/2 - currentDrag.data("height")/2)){
                        finalY=-(currentDrag.outerWidth(false)/2 - currentDrag.data("height")/2);
                    }else if (finalY> $("#gameSpace").innerHeight()-(currentDrag.outerHeight(false)/2 + currentDrag.data("height")/2)){
                        finalY = $("#gameSpace").innerHeight()-(currentDrag.outerHeight(false)/2 + currentDrag.data("height")/2);
                    }
                    newTowerDiv.css("top",finalY)
                                .css("left",finalX);
                    //add handler for following mouse
                    $('#gameSpace').mousemove( function(e) {
                        mouseX = e.pageX; 
                        mouseY = e.pageY;
                        finalX = e.pageX-$("#gameSpace").offset().left-currentDrag.outerHeight(false)/2;
                        finalY = e.pageY-$("#gameSpace").offset().top-currentDrag.outerWidth(false)/2;
                        if (finalX<-(currentDrag.outerWidth(false)/2 - currentDrag.data("width")/2)){
                            finalX=-(currentDrag.outerWidth(false)/2 - currentDrag.data("width")/2);
                        }else if(finalX> $("#gameSpace").innerWidth()-3-(currentDrag.outerWidth(false)/2 + currentDrag.data("width")/2)){
                            finalX = $("#gameSpace").innerWidth()-3-(currentDrag.outerWidth(false)/2 + currentDrag.data("width")/2);
                        }
                        if (finalY<-(currentDrag.outerWidth(false)/2 - currentDrag.data("height")/2)){
                            finalY=-(currentDrag.outerWidth(false)/2 - currentDrag.data("height")/2);
                        }else if (finalY> $("#gameSpace").innerHeight()-(currentDrag.outerHeight(false)/2 + currentDrag.data("height")/2)){
                            finalY = $("#gameSpace").innerHeight()-(currentDrag.outerHeight(false)/2 + currentDrag.data("height")/2);
                        }
                        currentDrag.css("top",finalY)
                                    .css("left",finalX);
                        
                        $(".tile").each(function(i,e){
                            var colliding = false;
                            if (tileCollision($(this),currentDrag.children(".tower"))){
                                colliding = true
                                currentDrag.addClass("isColliding");
                                //break loop
                                return false;
                            }else if (i==$(".tile").length-1){
                                currentDrag.removeClass("isColliding");
                            }
                        });
                    }); 
                    $('#gameSpace').mousedown(placeTower);

                }

                function placeTower(e){
                    if (!(currentDrag.hasClass("isColliding"))){
                            //buy tower
                            $('#gameSpace').unbind("mousemove");
                            $('#gameSpace').unbind("mousedown",placeTower);
                            currentDrag.removeClass("isDragging");
                            currentDrag.children(".tower").click(selectTower);
                            //set tower as tile
                            currentDrag.children(".tower").addClass("tile");
                            currentDrag=null;
                    }
                }
                function findTarget(tower){
                    var targetingDisk = tower.children(".targetDisk");
                    var enemiesColliding = [];
                    $(".enemy").each(function(i,e){
                        if (crCollision(targetingDisk,$(this))==true){
                            enemiesColliding.push(this);
                        }
                    });
                    if (enemiesColliding.length>0){
                        //rank enemies by distance travelled
                        enemiesColliding = rankByDistance(enemiesColliding);
                        //shoot at first one
                        return enemiesColliding[0];
                    }else{
                        return null;
                    }
                }

                function selectTower(evt){
                    removeTowerSelection();
                    $(this).parent().addClass("isSelected");
                    showTowerOverlay();
                    updateActiveTowerInfo();
                }

                function showTowerOverlay(){
                    $("#sideBarTowerControl").velocity("slideDown",100);
                }

                function fireTower(tower,target){
                    var projectileName = tower.data("projectileFired");
                    var projectileDiv = loadProjectile(projectileName).clone();
                    var projectileSpeed = projectileDiv.data("speed");
                    //set damage of tower
                    projectileDiv.data("damage",tower.data("damage"));
                    projectileDiv.data("target",target);
                    //calculate flight path of projectile
                    var targetPosition = {"x":target.data("currentX")+target.outerWidth(false)/2,
                                          "y":target.data("currentY")+target.outerHeight(false)/2};
                    var startPosition = {"x":tower.children(".tower").offset().left-$("#gameSpace").offset().left+tower.children(".tower").outerWidth(false)/2,
                                         "y":tower.children(".tower").offset().top-$("#gameSpace").offset().top+tower.children(".tower").outerHeight(false)/2};
                    //spawn projectile
                    $("#gameSpace").append(projectileDiv);
                    projectileDiv.css("left",startPosition.x)
                                    .css("top",startPosition.y);
                    projectileDiv.velocity({
                        top:targetPosition.y,
                        left:targetPosition.x
                    },baseClock/clockMultiplier,"linear",{queue:false});
                }

                function checkProjectileCollisions(){
                    $(".projectile").each(function(){
                        var damage = $(this).data("damage");
                        var target = $(this).data("target");
                        $(this).remove();
                        var targetHealth = target.data("health");
                        targetHealth-=damage;
                        if (targetHealth<=0){
                            enemyKilled(target);
                        }else{
                            target.data("health",targetHealth);
                        }
                    })
                }

                function enemyKilled(enemy){
                    enemy.remove();
                    setResources(resources+enemy.data("resources"));
                }

                function loadProjectile(projectileName){
                    if ((projectileName in projectileDB)==false){
                        var data = $.ajax({
                            type: "GET",
                            url: "gameComponents/projectiles/"+projectileName+".pd",
                            dataType: 'json',
                            async: false,
                            success: function(data) {}
                        })['responseJSON'];
                        var projectileDiv = $("<img class='projectile "+projectileName+"' style='height:"+data["height"]+"px; width:"+data["width"]+"px;' data-speed='"+data["speed"]+"' src='gameComponents/projectiles/"+data["icon"]+"'>");
                        data["divBase"]=projectileDiv;
                        projectileDB[projectileName]=data;
                        return projectileDiv;
                    }else{
                        return projectileDB[projectileName]["divBase"];
                    }
                }
            
                function flashWarning(message,duration){
                    duration = typeof duration !== 'undefined' ? duration : 5000;
                    showWarning(message);
                    warningMessageTimeout = setTimeout(hideWarning,duration);
                }    
            
                function showWarning(message){
                    clearTimeout(warningMessageTimeout);
                    $("#warning").show();
                    $("#warningText").html(message);
                }
            
                function hideWarning(){
                    $("#warning").hide();
                    $("#warningText").empty();
                }
                
                return{
                    clockTick: function(){
                        if (clockTickRunning==false){
                            clockTick();
                        }else{
                            //invalidate game as attempted to break it. Do not send high score, do not save.
                            valid=false;
                            console.error("Stop trying!");
                            flashWarning("Stop trying to cheat!");
                        }   
                    },
                    setMap:function(mapInfo){
                        loadMap(mapInfo["mapData"]);
                    },
                    exitGame: function(){
                        exitGame();
                    }
                }
            })();
            
            
        </script>
    </head>
    <body>
        <div id="controlTray">
            <div id="timeControls">
                <img class="timeControl" id="pause" data-speed="0" src="gameComponents/images/pause.png">
                <img class="timeControl" id="play0.5X" data-speed="0.5" src="gameComponents/images/halfPlay.png">
                <img class="timeControl selectedTimeControl" id="play1X" data-speed="1" src="gameComponents/images/play.png">
                <img class="timeControl" id="play2X" data-speed="2" src="gameComponents/images/ff2x.png">
                <img class="timeControl" id="play3X" data-speed="4" src="gameComponents/images/ff3x.png">
            </div> 
            <div class="sideBarDiv" id="waveControls">
                <img id="timeRemianingImage" src="gameComponents/images/timeRemaining.png">
                <span id="timeRemaining">30</span>
                <button id="startWave">Start wave</button>
            </div>
            <div class="sideBarDiv" id="healthStats">
                <img class="sideBarImage" id="healthImage" src="gameComponents/images/health.png">
                <span class="sideBarStatText" id="healthValue">100</span>
                <img class="sideBarImage" id="resourcesImage" src="gameComponents/images/resources.png">
                <span class="sideBarStatText" id="resourceValue">200</span>
                <div id="healthBar"></div>
            </div>
            <div class="sideBarDiv" id="warning">
                <span id="warningText"></span>
            </div>
            <div class="sideBarDiv" id="sideBarTowerControl">
                <span class="sideBarDivTitle">Tower info</span>
                <img id="activeTowerImage">
                <ul class='activeTowerInfo'>
                    <li>
                        <img class='sideBarActiveTowerStatImage' src='gameComponents/images/attack.png'>
                        <span class='sideBarActiveTowerStatText' id="activeTowerAttack">10</span>
                        <span class='sideBarActiveTowerStatText statModifier' id="statModifierAtttack">+3</span>
                    </li>
                    <li>
                        <img class='sideBarActiveTowerStatImage' src='gameComponents/images/range.png'>
                        <span class='sideBarActiveTowerStatText' id="activeTowerRange">10</span>
                        <span class='sideBarActiveTowerStatText statModifier' id="statModifierRange">+3</span>
                    </li>
                    <li>
                        <img class='sideBarActiveTowerStatImage' src='gameComponents/images/reload.png'>
                        <span class='sideBarActiveTowerStatText' id="activeTowerReloadSpeed">4</span>
                        <span class='sideBarActiveTowerStatText statModifier' id="statModifierReloadSpeed">+3</span>
                    </li>
                    <li>
                        <img class='sideBarActiveTowerStatImage' src='gameComponents/images/resources.png'>
                        <span class='sideBarActiveTowerStatText' id="activeTowerCost">10</span>
                        <span class='sideBarActiveTowerStatText statModifier' id="statModifierCost">+3</span>
                    </li>
                </ul>
                <ul class='upgradeTowerInfo'>
                    <li>
                        <img class='sideBarActiveTowerStatImage' src='gameComponents/images/attack.png'>
                        <span class='sideBarActiveTowerStatText' id="upgradeTowerAttack">+3</span>
                    </li>
                    <li>
                        <img class='sideBarActiveTowerStatImage' src='gameComponents/images/range.png'>
                        <span class='sideBarActiveTowerStatText' id="upgradeTowerRange">+3</span>
                    </li>
                    <li>
                        <img class='sideBarActiveTowerStatImage' src='gameComponents/images/reload.png'>
                        <span class='sideBarActiveTowerStatText' id="upgradeTowerReloadSpeed">+2</span>
                    </li>
                    
                </ul>
                <div id="activeTowerButtons">
                    <button class="sideBarTowerButton" id="sellTower">Sell</button>
                    <button class="sideBarTowerButton" id="upgradeTower">Upgrade</button>
                    <span class='upgradeTowerInfo'>
                        <img class="sideBarUpgradeTowerStatImage" src='gameComponents/images/resources.png'>
                        <span id="upgradeTowerCost">60</span>
                    </span>
                </div>
                
            </div>
            <div class="sideBarDiv" id="sideBarTowerSlots">
                <span class="sideBarDivTitle">Buy towers</span>
            </div>
        </div>
        <div id="gameSpace">
        </div>
    </body>
</html>